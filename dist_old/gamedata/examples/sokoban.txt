/gamedata/examples/sokoban_tileset.png
--------
{
    "name": "Sokoban v2",
    "version": "2.0.1",
    "tile_size": 32,
    "game_area": {
      "nb_tile_width": 20,
      "nb_tile_height": 14
    },
    "img_coords": {
        "herb": [0, 0],
        "wall": [32, 0],
        "crate": [64, 0],
        "avatar": [0, 32],
        "target": [32, 32]
    }
}
--------
"""
Petite démonstration de la V2 du moteur de Squarity,
avec un grand classique: Soko-ban.

Les commentaires expliquent le fonctionnement du code, ce qui pourra
vous aider si vous souhaitez créer vos propres jeux.

Il est conseillé de tester et de comprendre les mini-exemples
avant de s'attaquer à la lecture du code de ce jeu.
Vous les trouverez dans la section "Créer des jeux" de Squarity.
"""

import squarity
Coord = squarity.Coord
s = squarity.Sequencer

# Cette variable contient la définition de tous les niveaux.
# Il s'agit d'un tuple, dont chaque élément est un sous-tuple,
# # de deux sous-éléments :
#  - Une chaîne de caractère, décrivant le niveau.
#    Elle s'affiche dans le log de squarity, au début du niveau.
#  - Le second élément est une sous-sous-tuple de 14 chaînes de caractères,
#    correspondant au plan du niveau.
LEVELS_AND_DESCRIPTIONS = (
    (
        "Origine de ce niveau : http://www.sokobano.de/wiki/index.php?title=Optimizer",
        (
            "                    ",
            "          ####      ",
            "         ##. ##     ",
            "     ##### .  #     ",
            "     #   #  # #     ",
            "     # $ #  # #     ",
            "     # $      #     ",
            "     ######  ##     ",
            "          # ##      ",
            "          # #       ",
            "          # #       ",
            "         ## ##      ",
            "         # @ #      ",
            "         #   #      ",
        )
    ),
    (
        "Origine : https://www.mathsisfun.com/games/sokoban.html (un peu transformé)",
        (
            "    #####           ",
            "    #   #      ###  ",
            "    #$  #      #.#  ",
            "  ###  $###    # #  ",
            "  #  $  $ #   ## ###",
            "### # ### #   #   .#",
            "#   # ### #####  ###",
            "# $  $           ..#",
            "########### ###  ###",
            "          # # #   .#",
            "          # # ## ###",
            "          # #  # #  ",
            "          # #  #.#  ",
            "          #@#  ###  ",
        )
    ),
    (
        "Origine : https://www.mathsisfun.com/games/sokoban.html",
        (
            "                    ",
            "                    ",
            "                    ",
            "         #####      ",
            "##########   #      ",
            " @      . $  #      ",
            "########## $.#      ",
            "       #.##$ #      ",
            "       # # . ##     ",
            "       #$ *$$.#     ",
            "       #   .  #     ",
            "       ## #####     ",
            "        # #         ",
            "        # #         ",
        )
    ),
    (
        "Origine : https://alonso-delarte.medium.com/the-basics-of-sokoban-level-formats-"
        "for-designing-your-own-sokoban-levels-51882a7a36f0",
        (
            "       #####        ",
            "   #####   #####    ",
            "   #           #    ",
            "   #  ### ###  #    ",
            " #### #     # ####  ",
            "##    #  *  #    #  ",
            "   $  # *+*      #  ",
            "##    #  *  #    #  ",
            " #### #     # ####  ",
            "   #  ### ###  #    ",
            "   #           #    ",
            "   #####   #####    ",
            "       #####        ",
            "                    ",
        ),
    ),
    (
        "Bravo, vous avez réussi tous les niveaux. Pourquoi ne pas en profiter pour créer les vôtres ?",
        (
            "         @          ",
            "#  #  ### #   #  #  ",
            "#  #  #    # #   #  ",
            "####  ##    #    #  ",
            "#  #  #     #       ",
            "#  #  ###   #    #  ",
            "                    ",
            "        ####        ",
            "       #    #       ",
            "      # .  . #      ",
            "      #      #      ",
            "      #  ..  #      ",
            "       #    #       ",
            "        ####        ",
        ),
    ),
)

# Les correspondances entre un caractère écrit dans les plans du niveau,
# et la liste de game objects qu'il faut placer sur la tile.
# Les caractères respectent le format officiel des niveaux de soko-ban :
# http://sokobano.de/wiki/index.php?title=Level_format
ELEMS_FROM_CHAR = {
    " ": ["herb"],
    "#": ["herb", "wall"],
    "@": ["herb", "avatar"],
    "$": ["herb", "crate"],
    ".": ["herb", "target"],
    "+": ["herb", "target", "avatar"],
    "*": ["herb", "target", "crate"],
}


class GameModel(squarity.GameModelBase):

    def on_start(self):
        """
        Fonction exécutée automatiquement par le moteur Squarity, au début du jeu.
        """
        # Définition du temps de transition pour tous les objets.
        # Lorsqu'un objet doit se déplacer d'une case vers une autre,
        # l'affichage du mouvement pixel par pixel dure maintenant 70 millisecondes.
        self.transition_delay = 70
        # Ce jeu utilise trois layers :
        #  - layer_background, contient l'herbe, les murs et les targets
        #    (les éléments qui ne bougent pas d'un niveau à l'autre)
        #  - layer_crate, contient les caisses
        #  - layer_main, contient l'avatar (le personnage que l'on déplace)
        self.layer_background = squarity.Layer(self, self.w, self.h, False)
        self.layer_crate = squarity.Layer(self, self.w, self.h, True)
        self.layers.insert(0, self.layer_background)
        self.layers.insert(1, self.layer_crate)

        # L'avatar est arbitrairement placé aux coordonnées (0, 0).
        # Il sera repositionné à l'initialisation du niveau en cours.
        self.gobj_avatar = squarity.GameObject(Coord(0, 0), "avatar")
        # Les mouvements de l'avatar bloquent l'interface du jeu.
        # Ça évite de se retrouver avec des décalages bizarres lorsque l'avatar
        # se déplace seul, puis qu'il pousse une caisse.
        self.gobj_avatar.plock_transi = squarity.PlayerLockTransi.INVISIBLE
        self.layer_main.add_game_object(self.gobj_avatar)
        # Index du niveau en cours (compté à partir de 0).
        self.current_level = 0
        # Initialisation du niveau en cours (donc du premier niveau).
        self.initiate_level()
        # Booléen permettant de demander une confirmation lorsque la
        # personne qui joue veut réinitialiser le niveau.
        # Elle devra appuyer deux fois de suite sur le bouton d'action "1".
        self.restart_level = False

    def initiate_level(self):
        """
        Cette fonction est appelée à chaque initialisation de niveau.
        Soit lors d'une réinitialisation du niveau actuel,
        soit lors du passage au niveau suivant.
        """
        descrip, level_map = LEVELS_AND_DESCRIPTIONS[self.current_level]
        print(descrip)
        # Correspondance entre le type de game object et le layer où le placer.
        # L'avatar n'est pas mentionné dans ces correspondances, car il est
        # géré spécifiquement.
        layer_from_elem = {
            "herb": self.layer_background,
            "wall": self.layer_background,
            "crate": self.layer_crate,
            "target": self.layer_background,
        }
        # Itération sur toutes les coordonnées de l'aire de jeu.
        # C'est plus simple que de faire deux boucles imbriquée sur X et Y.
        for coord in s.iter_on_rect(self.rect):
            # On enlève tous les objets existants des deux layers, pour nettoyer
            # ce qui provenait du niveau précédent.
            self.layer_background.remove_at_coord(coord)
            self.layer_crate.remove_at_coord(coord)

            elems_to_add = ELEMS_FROM_CHAR[level_map[coord.y][coord.x]]
            for elem in elems_to_add:
                if elem == "avatar":
                    # Cas particulier. C'est l'avatar. On ne crée pas de nouvel objet.
                    # On place instantanément l'avatar existant au bon endroit.
                    self.gobj_avatar.move_to(coord, 0)
                else:
                    # Cas générique. Il faut créer de l'herbe/un mur/une cible/une caisse,
                    # et le placer dans le layer adéquat.
                    layer = layer_from_elem[elem]
                    layer.add_game_object(squarity.GameObject(coord, elem))

    def on_button_direction(self, direction):
        """
        Cette fonction est exécutée à chaque fois qu'un des 4 boutons de direction
        est activé.
        """
        # Si on était en train de demander une confirmation pour réinitialiser le
        # niveau, on annule cette demande.
        self.restart_level = False
        # Détermination de la destination de l'avatar, si le mouvement prévu est valide.
        # Il s'agit de la position actuelle, déplacée d'une case dans la direction activée.
        avatar_dest = self.gobj_avatar.get_coord().move_dir(direction)
        if not self.rect.in_bounds(avatar_dest):
            # Le mouvement ferait sortir l'avatar de l'écran. Ce n'est pas valide.
            # On ne fait rien.
            return
        if self.get_first_gobj(avatar_dest, ["wall"], self.layer_background):
            # Le mouvement mettrait l'avatar dans un mur. Ce n'est pas valide non plus.
            return

        # On vérifie si il y a une caisse sur la case de destination de l'avatar.
        crate_to_push = self.get_first_gobj(
            avatar_dest,
            ["crate"],
            self.layer_crate,
        )
        if crate_to_push is not None:
            # Il y a bien une caisse. Elle est censée être poussée, dans la même
            # direction que l'avatar. Mais avant, il faut vérifier si c'est possible.
            # Détermination de la destination de la caisse.
            # Ça correspond à la destination de l'avatar, mais décalée d'encore une case.
            crate_dest = avatar_dest.clone().move_dir(direction)
            if not self.rect.in_bounds(crate_dest):
                # Le mouvement pousserait la caisse hors de l'écran.
                # Ce n'est pas valide. On ne fait rien, pas de déplacement de caisse
                # ni de déplacement d'avatar.
                return
            if self.get_first_gobj(crate_dest, ["wall", "crate"]):
                # Le mouvement pousserait la caisse dans un mur, ou dans une autre caisse.
                # Ce n'est pas valide non plus.
                return
            # On a tout vérifié pour le mouvement de la caisse. On la déplace.
            crate_to_push.move_dir(direction)

        # On a entièrement tout vérifié. On déplace l'avatar (avec ou sans caisse)
        self.gobj_avatar.move_dir(direction)
        # Vérification si toutes les caisses sont sur les cibles.
        # On ne devrait faire cette vérif que si une caisse a été poussée, mais bon...
        # Là on le fait systématiquement, c'est un peu bourrin.
        return self.check_crate_on_target()

    def check_crate_on_target(self):
        """
        Vérifie si toutes les caisses ne sont pas sur les cibles.
        Si oui, renvoie une instance de "EventResult". Ce sont des informations
        spécifiques envoyées au moteur de Squarity, indiquant qu'il faudra
        exécuter une autre fonction plus tard (lorsque l'avatar aura fini
        sa danse de la victoire).
        Si toutes les caisses ne sont pas sur les cibles, la fonction renvoie None,
        et il ne se passe rien de spécial.
        """

        # Itération sur toutes les coordonnées du jeu. On récupère, à chaque fois,
        # dans une mini-liste, tous les objets "target" et "crate" des layers
        # "layer_background" et "layer_crate", qui se trouvent sur les coordonnées courantes.
        for game_objects in s.seq_iter(
            s.iter_on_rect(self.rect),
            s.gobj_on_layers_by_coords(
                [self.layer_background, self.layer_crate]
            ),
            s.filter_sprites(["target", "crate"]),
        ):
            #  - Si cette mini-liste contient 0 éléments: pas de caisse ni de cible.
            #    C'est une case sans intérêt pour la vérification.
            #  - Si la mini-liste contient 1 élément, c'est une caisse toute seule
            #    ou une cible toute seule. Ça signifie que toutes les caisses ne sont
            #    pas sur des cibles. Le niveau n'est pas résolu. On quitte directement
            #    la fonction.
            #  - Si la mini-liste contient 2 éléments, c'est une caisse et une cible
            #    sur la même case. Ça ne bloque pas la résolution du niveau.
            #    On peut donc continuer de vérifier les autres cases.
            #    On ne vérifie pas que les 2 éléments sont 2 caisses ou 2 cibles.
            #    Par construction, avec le reste du code,
            #    il est impossible d'avoir cette situation.
            #  - Si la mini-liste contient plus de 2 éléments, ce n'est pas censé arriver.
            #    Dans le doute on quitte la fonction (mais on pourrait carrément
            #    lever une exception).
            if len(game_objects) not in (0, 2):
                return

        # Si on est arrivé jusqu'ici, toutes les cases ont été vérifiées.
        # Toutes les caisses sont sur des cibles. Le niveau est résolu. Yeah !
        print("Victoire !")
        # Il faut programmer la petite danse de victoire de l'avatar.
        # Il s'agit d'une séquence de mouvement qui s'exécute automatiquement.
        # Mais pour chaque mouvement, il faut s'assurer que ça ne sorte pas
        # l'avatar de l'aire de jeu.
        # victory_dance contiendra des tuples de 2 éléments :
        #  - temps, en millisecondes, pour réaliser un mouvement de la séquence.
        #  - coordonnées de l'avatar, pour ce mouvement.
        victory_dance = []
        # La danse de la victoire est constitué de 4 "sauts", durant lesquels
        # l'avatar se déplace sur une case adjacente, puis revient à sa position initiale.
        dir_jumps = (
            squarity.dirs.UpLeft,
            squarity.dirs.UpRight,
            squarity.dirs.Up,
            squarity.dirs.Up,
        )
        coord_jump_back = self.gobj_avatar.get_coord()
        for dir_jump in dir_jumps:
            # On vérifie, pour le saut en cours, que la position de destination
            # ne sorte pas de l'écran.
            coord_jump = coord_jump_back.clone().move_dir(dir_jump)
            if self.rect.in_bounds(coord_jump):
                # C'est ok. On ajoute deux mouvements à la séquence (avec le même temps).
                # Le premier mouvement correspond au saut, le second au retour
                # à sa position initiale.
                victory_dance.append((150, coord_jump))
                victory_dance.append((150, coord_jump_back))

        if victory_dance:
            # Il y a au moins un mouvement dans la séquence. On ajoute
            # toute la séquence dans l'avatar. Le moteur de squarity se chargera
            # de l'effectuer automatiquement.
            self.gobj_avatar.add_transition(
                squarity.TransitionSteps("coord", victory_dance)
            )
        # En plus de définir la danse de la victoire, on indique au moteur
        # qu'il faudra exécuter une fonction python spécifique, dans 1800 millisecondes.
        # La plus longue séquence de victoire dure (150 millisecondes) * (8 mouvements),
        # soit 1500 millisecondes. Elle aura donc le temps de s'exécuter entièrement.
        # La fonction à exécuter est "end_anim_victory". Elle fera passer le jeu
        # au niveau suivant.
        event_result = squarity.EventResult()
        event_result.add_delayed_callback(
            squarity.DelayedCallBack(1800, self.end_anim_victory)
        )
        # On locke explicitement toute l'interface du jeu pendant la danse de la victoire.
        # Les clics de souris et les appuis de touche ne seront pas pris en compte.
        event_result.plocks_custom.append("victory_anim")
        return event_result

    def end_anim_victory(self):
        """
        Fonction exécutée par le moteur de squarity, lorsqu'on lui renvoie un EventResult
        indiquant qu'il faut l'exécuter au bout d'un délai.
        Cette fonction fait passer au niveau suivant.
        """
        # On avance l'index du niveau courant.
        self.current_level += 1
        # Si on a dépassé le nombre de niveau existants, on revient au premier niveau.
        # Ce n'est pas censé arriver car le dernier niveau ne peut pas être résolu.
        # Mais on prévoit le cas où la personne qui joue aurait modifié les niveaux
        # en bidouillant le code.
        if self.current_level >= len(LEVELS_AND_DESCRIPTIONS):
            self.current_level = 0
        # Initialisation du niveau suivant
        # (repositionnement de l'avatar, affichage des murs, caisses, etc)
        self.initiate_level()
        # On délocke l'interface du jeu, qui avait été lockée pendant la danse de la victoire.
        event_result = squarity.EventResult()
        event_result.punlocks_custom.append("victory_anim")
        return event_result

    def on_button_action(self, action_name):
        """
        Fonction exécutée lors de l'appui sur le bouton d'action "1" ou "2".
        (Seule l'action "1" a un effet).
        """
        if action_name == "action_1":
            if self.restart_level:
                # Une réinitalisation a été préalablement demandée, et elle est confirmée.
                # Il faut juste exécuter la fonction d'initialisation d'un niveau,
                # sans modifier la virable self.current_level.
                # Ça remettra tout comme c'était au début du niveau. Les caisses, l'avatar, etc.
                self.initiate_level()
                self.restart_level = False
            else:
                # On demande confirmation pour réinitialiser le niveau.
                print("Appuyez une seconde fois sur le bouton '1' pour redémarrer le niveau.")
                # On retient que la demande a été faite, au cas où l'action "1"
                # est réactivée juste après.
                self.restart_level = True
