import{_ as a,o as t,c as d,e as o}from"./index-86c22afc.js";const s="/assets/schema_game_sizes-0f4294ce.png",n="/assets/schema_sprite_infos-173149e9.png";const r={},i={class:"doc-article"};function c(l,e){return t(),d("div",i,[...e[0]||(e[0]=[o(`<h1 id="documentation-de-r√©f√©rence-de-squarity-v2" data-v-8d22b233>Documentation de r√©f√©rence de Squarity V2 <a class="header-anchor" href="#documentation-de-r√©f√©rence-de-squarity-v2" data-v-8d22b233>üîó</a></h1><p data-v-8d22b233>Squarity est un espace de cr√©ation et de partage de jeux vid√©o jouables dans un navigateur web. Les jeux se d√©roulent sur une grille en 2D compos√©e de carr√©s. Le fonctionnement et les r√®gles du jeu sont d√©finis par du code en python.</p><p data-v-8d22b233>Ce document d√©crit les fonctionnalit√©s de la version 2.1.0 du moteur de Squarity. Il suppose que vous avez d√©j√† un minimum de connaissance en python. Si ce n&#39;est pas le cas, vous pouvez les acqu√©rir avec la doc <a href="https://diveintopython.org/fr/learn" data-v-8d22b233>&quot;dive into python&quot; en fran√ßais</a>.</p><p data-v-8d22b233>Un jeu est d√©fini par trois informations :</p><ul data-v-8d22b233><li data-v-8d22b233>le tileset,</li><li data-v-8d22b233>la configuration,</li><li data-v-8d22b233>le &quot;game code&quot;.</li></ul><p data-v-8d22b233>Pour l&#39;instant, Squarity ne g√®re pas de comptes ni de profil personnel. Vous devez sauvegarder vos jeux par vous-m√™me. Vous pouvez les distribuer en <a href="https://squarity.pythonanywhere.com/create/share-your-game" data-v-8d22b233>les publiant sur un gist github</a>.</p><h2 id="le-tileset" data-v-8d22b233>Le tileset <a class="header-anchor" href="#le-tileset" data-v-8d22b233>üîó</a></h2><p data-v-8d22b233>Le tileset est comme un atlas : c&#39;est une image regroupant toutes les &quot;sous-images&quot; des √©l√©ments de votre jeu (d√©cor, personnages, bonus, ...).</p><p data-v-8d22b233>Pour que votre tileset soit accessible dans Squarity, il doit √™tre publi√© sur internet : dans un repository github, sur un site d&#39;h√©bergement d&#39;images, etc.</p><p data-v-8d22b233>Dans l&#39;interface de Squarity, indiquez le lien direct vers votre fichier image dans le champ &quot;Url de l&#39;image&quot;.</p><h2 id="configuration-json" data-v-8d22b233>Configuration json <a class="header-anchor" href="#configuration-json" data-v-8d22b233>üîó</a></h2><p data-v-8d22b233>Exemple :</p><pre data-v-8d22b233><code data-v-8d22b233>{
    &quot;name&quot;: &quot;Mon super jeu&quot;,
    &quot;version&quot;: &quot;2.1.0&quot;,
    &quot;tile_size&quot;: 32,
    &quot;game_area&quot;: {
      &quot;nb_tile_width&quot;: 20,
      &quot;nb_tile_height&quot;: 14
    },
    &quot;img_coords&quot;: {
      &quot;my_sprite&quot;: [0, 0],
      &quot;my_other_sprite&quot;: [32, 0]
    }
}
</code></pre><p data-v-8d22b233>Dans l&#39;interface, cette configuration doit √™tre √©crite dans la zone de texte &quot;Config du jeu&quot;.</p><h3 id="informations-g√©n√©rales-de-la-config" data-v-8d22b233>Informations g√©n√©rales de la config <a class="header-anchor" href="#informations-g√©n√©rales-de-la-config" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233><code data-v-8d22b233>name</code> (cha√Æne de caract√®re) : le nom de votre jeu. Il sera √©crit dans le titre de la page web, pr√©c√©d√© du texte &quot;Squarity - &quot;.</p><p data-v-8d22b233><code data-v-8d22b233>version</code> (cha√Æne de caract√®re) : version du moteur du jeu, indiquez &quot;2.1.0&quot;. (<a href="#version-du-moteur-squarity" data-v-8d22b233>Voir Version&quot;</a>).</p><p data-v-8d22b233><code data-v-8d22b233>tile_size</code> (nombre entier) : la taille par d√©faut, en pixels dans le tileset, des images repr√©sentant les √©l√©ments de votre jeu.</p><p data-v-8d22b233><code data-v-8d22b233>game_area</code> (sous-dictionnaire contenant deux nombres entiers) : largeur et hauteur de l&#39;aire de jeu, en nombre de cases (tiles).</p><h3 id="d√©finition-des-images" data-v-8d22b233>D√©finition des images <a class="header-anchor" href="#d√©finition-des-images" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>Il s&#39;agit des images repr√©sentant les √©l√©ments de votre jeu (les &quot;Game Objects&quot;). Elles sont d√©finies par un sous-dictionnaire, situ√© dans <code data-v-8d22b233>img_coords</code>.</p><p data-v-8d22b233>Chaque cl√© de ce sous-dictionnaire est une cha√Æne de caract√®re que vous pourrez utiliser dans votre code python, pour sp√©cifier l&#39;image d&#39;un Game Object.</p><p data-v-8d22b233>Chaque valeur de ce sous-dictionnaire est une liste de 2 entiers, repr√©sentant les coordonn√©es x et y, en pixels dans le tileset, du coin sup√©rieur gauche de l&#39;image.</p><p data-v-8d22b233>Il est possible d&#39;ajouter d&#39;autres valeurs apr√®s ces deux entiers. <a href="#info-suppl%C3%A9mentaires-pour-les-sprites" data-v-8d22b233>Voir &quot;Info suppl√©mentaires pour les sprites&quot;</a>.</p><h3 id="version-du-moteur-squarity" data-v-8d22b233>Version du moteur Squarity <a class="header-anchor" href="#version-du-moteur-squarity" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>La seule information utile de la cl√© <code data-v-8d22b233>version</code> est le premier nombre.</p><p data-v-8d22b233>Si ce nombre est &quot;1&quot;, la version utilis√©e sera &quot;1.0.0&quot;.</p><p data-v-8d22b233>Si ce nombre est &quot;2&quot;, la version utilis√©e sera la version 2.x.y la plus r√©cente (actuellement : &quot;2.1.0&quot;). Vous n&#39;avez pas acc√®s aux pr√©c√©dentes versions 2.x.y, mais elles sont cens√©es √™tre r√©tro-compatibles.</p><h2 id="notions-de-base-du-game-code" data-v-8d22b233>Notions de base du &quot;game code&quot; <a class="header-anchor" href="#notions-de-base-du-game-code" data-v-8d22b233>üîó</a></h2><p data-v-8d22b233>Il s&#39;agit du programme d√©finissant la logique de votre jeu, il est √©crit en langage python.</p><p data-v-8d22b233>Dans l&#39;interface, placez ce programme dans la zone de texte intitul√©e &quot;Le code du jeu&quot;.</p><p data-v-8d22b233>Ce programme doit contenir une classe intitul√©e <code data-v-8d22b233>GameModel</code>, qui h√©rite de la classe <code data-v-8d22b233>squarity.GameModelBase</code>.</p><p data-v-8d22b233>Cette classe sera instanci√©e par le moteur Squarity. Elle contient des fonctions de callback qui seront automatiquement appel√©es sur certains √©v√©nements (appui sur un bouton du jeu, clic de souris, etc.)</p><p data-v-8d22b233>Votre <code data-v-8d22b233>GameModel</code> contient des objets de type <code data-v-8d22b233>squarity.Layer</code>, ordonn√©s dans une liste. Chacun de ces layers contient un tableau en 2 dimensions avec des &quot;tiles&quot;. La largeur et la hauteur correspondent √† celles de l&#39;aire de jeu (c&#39;est √† dire les valeurs <code data-v-8d22b233>nb_tile_width</code> et <code data-v-8d22b233>nb_tile_height</code> indiqu√©es dans la config JSON).</p><p data-v-8d22b233>Une tile repr√©sente une case de l&#39;aire de jeu. Chaque tile peut contenir plusieurs <code data-v-8d22b233>squarity.GameObject</code>, repr√©sentant des objets de votre jeu.</p><ul data-v-8d22b233><li data-v-8d22b233>Un GameObject est toujours plac√© sur une seule tile de un seul layer.</li><li data-v-8d22b233>Un GameObject poss√®de des coordonn√©es (x, y) indiquant la tile d&#39;appartenance dans le layer.</li><li data-v-8d22b233>Un GameObject poss√®de une variable membre <code data-v-8d22b233>sprite_name</code>, de type cha√Æne de caract√®re. Cette variable doit avoir pour valeur l&#39;un des noms d√©finis dans le dictionnaire <code data-v-8d22b233>img_coords</code> de la configuration JSON.</li></ul><p data-v-8d22b233>La suite de cette documentation contient des exemples de code. Pour les essayer :</p><ul data-v-8d22b233><li data-v-8d22b233>chargez le jeu de l&#39;√©meraude verte (qui fonctionne en version 2.1.0),</li><li data-v-8d22b233>copier-collez le code d&#39;exemple dans la fen√™tre du code,</li><li data-v-8d22b233>cliquez sur le bouton &quot;Ex√©cuter&quot;.</li></ul><p data-v-8d22b233>Vous devriez voir des informations appara√Ætre dans la fen√™tre de texte en bas de l&#39;aire de jeu.</p><p data-v-8d22b233>Les exemples de code qui ne commencent pas par la ligne <code data-v-8d22b233>import squarity</code> doivent √™tre <strong data-v-8d22b233>ajout√©s</strong> dans le code existant, juste apr√®s la ligne <code data-v-8d22b233>import squarity</code> d√©j√† pr√©sente.</p><p data-v-8d22b233>Les exemples de code commen√ßant par <code data-v-8d22b233>import squarity</code> sont plus complets, ils doivent <strong data-v-8d22b233>remplacer</strong> tout le code existant.</p><h2 id="sch√©ma-daffichage-calculs-des-tailles" data-v-8d22b233>Sch√©ma d&#39;affichage, calculs des tailles <a class="header-anchor" href="#sch√©ma-daffichage-calculs-des-tailles" data-v-8d22b233>üîó</a></h2><p data-v-8d22b233>Vous ne pouvez pas d√©finir la taille en pixel des cases r√©ellement affich√©es, car cette taille s&#39;adapte automatiquement √† la fen√™tre du navigateur affichant Squarity.</p><p data-v-8d22b233>Le calcul est effectu√© comme suit :</p><ul data-v-8d22b233><li data-v-8d22b233>d√©termination des plus grandes valeurs possibles pour la largeur et la hauteur des tiles (en pixel, √† l&#39;√©cran) : <ul data-v-8d22b233><li data-v-8d22b233><code data-v-8d22b233>largeur_case_temp = largeur_affichage // config.game_area.nb_tile_width</code></li><li data-v-8d22b233><code data-v-8d22b233>hauteur_case_temp = hauteur_affichage // config.game_area.nb_tile_height</code></li></ul></li><li data-v-8d22b233>d√©termination de la taille r√©elle des tiles, en prenant la plus petite : <ul data-v-8d22b233><li data-v-8d22b233><code data-v-8d22b233>taille_case_affichage = min(largeur_case_temp, hauteur_case_temp)</code></li></ul></li><li data-v-8d22b233>application de cette taille pour la largeur et la hauteur √† l&#39;√©cran : <ul data-v-8d22b233><li data-v-8d22b233><code data-v-8d22b233>largeur_case_affichage = taille_case_affichage</code></li><li data-v-8d22b233><code data-v-8d22b233>hauteur_case_affichage = taille_case_affichage</code></li></ul></li></ul><p data-v-8d22b233>Ensuite, une mise √† l&#39;√©chelle des images est effectu√©e. On part de la taille d√©finie par <code data-v-8d22b233>config.tile_size</code> (en pixel de tileset), pour arriver √† des images ayant une taille √©gale √† <code data-v-8d22b233>taille_case_affichage</code> (en pixel d&#39;√©cran).</p><p data-v-8d22b233>La mise √† l&#39;√©chelle est effectu√©e selon l&#39;algorithme &quot;proche voisin&quot;, sans traitement ni anti-aliasing. Vous verrez donc des gros pixels carr√©s si vos images de tileset sont petites et que vous jouez dans une grande fen√™tre.</p><p data-v-8d22b233><img src="`+s+`" alt="Sch√©ma d√©crivant les tailles de case et d&#39;aire de jeu" data-v-8d22b233></p><h2 id="class-direction" data-v-8d22b233>class Direction <a class="header-anchor" href="#class-direction" data-v-8d22b233>üîó</a></h2><p data-v-8d22b233>Il s&#39;agit d&#39;une classe python dont il n&#39;existe que 8 instances : 4 pour les directions de base (haut, droite, bas, gauche) et 4 pour les diagonales. Ces 8 instances sont stock√©es dans l&#39;objet <code data-v-8d22b233>squarity.dirs</code>.</p><h3 id="liste-des-directions" data-v-8d22b233>Liste des directions <a class="header-anchor" href="#liste-des-directions" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>Les instances peuvent √™tre compar√©es entre elles, par exemple : <code data-v-8d22b233>my_dir == dirs.Up</code>. Elles peuvent √™tre converties en entier et en string. Elles poss√®dent une variable <code data-v-8d22b233>vector</code> : un tuple de deux √©l√©ments indiquant respectivement le d√©placement en X et le d√©placement en Y.</p><p data-v-8d22b233>Tableau r√©capitulatif des directions et de leurs caract√©ristiques :</p><table data-v-8d22b233><thead data-v-8d22b233><tr data-v-8d22b233><th data-v-8d22b233><code data-v-8d22b233>d = </code></th><th data-v-8d22b233><code data-v-8d22b233>int(d)</code></th><th data-v-8d22b233><code data-v-8d22b233>str(d)</code></th><th data-v-8d22b233><code data-v-8d22b233>d.vector[0]</code></th><th data-v-8d22b233><code data-v-8d22b233>d.vector[1]</code></th></tr></thead><tbody data-v-8d22b233><tr data-v-8d22b233><td data-v-8d22b233><code data-v-8d22b233>dirs.Up</code></td><td data-v-8d22b233>0</td><td data-v-8d22b233><code data-v-8d22b233>&quot;up&quot;</code></td><td data-v-8d22b233>0</td><td data-v-8d22b233>-1</td></tr><tr data-v-8d22b233><td data-v-8d22b233><code data-v-8d22b233>dirs.UpRight</code></td><td data-v-8d22b233>1</td><td data-v-8d22b233><code data-v-8d22b233>&quot;up_right&quot;</code></td><td data-v-8d22b233>+1</td><td data-v-8d22b233>-1</td></tr><tr data-v-8d22b233><td data-v-8d22b233><code data-v-8d22b233>dirs.Right</code></td><td data-v-8d22b233>2</td><td data-v-8d22b233><code data-v-8d22b233>&quot;right&quot;</code></td><td data-v-8d22b233>+1</td><td data-v-8d22b233>0</td></tr><tr data-v-8d22b233><td data-v-8d22b233><code data-v-8d22b233>dirs.DownRight</code></td><td data-v-8d22b233>3</td><td data-v-8d22b233><code data-v-8d22b233>&quot;down_right&quot;</code></td><td data-v-8d22b233>+1</td><td data-v-8d22b233>+1</td></tr><tr data-v-8d22b233><td data-v-8d22b233><code data-v-8d22b233>dirs.Down</code></td><td data-v-8d22b233>4</td><td data-v-8d22b233><code data-v-8d22b233>&quot;down&quot;</code></td><td data-v-8d22b233>0</td><td data-v-8d22b233>+1</td></tr><tr data-v-8d22b233><td data-v-8d22b233><code data-v-8d22b233>dirs.DownLeft</code></td><td data-v-8d22b233>5</td><td data-v-8d22b233><code data-v-8d22b233>&quot;down_left&quot;</code></td><td data-v-8d22b233>-1</td><td data-v-8d22b233>+1</td></tr><tr data-v-8d22b233><td data-v-8d22b233><code data-v-8d22b233>dirs.Left</code></td><td data-v-8d22b233>6</td><td data-v-8d22b233><code data-v-8d22b233>&quot;left&quot;</code></td><td data-v-8d22b233>-1</td><td data-v-8d22b233>0</td></tr><tr data-v-8d22b233><td data-v-8d22b233><code data-v-8d22b233>dirs.UpLeft</code></td><td data-v-8d22b233>7</td><td data-v-8d22b233><code data-v-8d22b233>&quot;up_left&quot;</code></td><td data-v-8d22b233>-1</td><td data-v-8d22b233>-1</td></tr></tbody></table><h3 id="rotations" data-v-8d22b233>Rotations <a class="header-anchor" href="#rotations" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>La m√©thode <code data-v-8d22b233>turn_cw</code> renvoie une direction tourn√©e dans le sens des aiguilles d&#39;une montre. La m√©thode <code data-v-8d22b233>turn_ccw</code> renvoie une direction tourn√©e dans le sens inverse. L&#39;angle de rotation par d√©faut est de 90 degr√©s.</p><pre data-v-8d22b233><code data-v-8d22b233>d = squarity.dirs.Right
print(d.turn_cw())
# La valeur &#39;down&#39; s&#39;affiche dans la console.
</code></pre><p data-v-8d22b233>Un param√®tre optionnel (nombre entier) permet de pr√©ciser l&#39;angle de rotation, en multiple de 45 degr√©s.</p><pre data-v-8d22b233><code data-v-8d22b233>d = squarity.dirs.UpRight
print(d.turn_ccw(3))
# La valeur &#39;left&#39; s&#39;affiche dans la console.
</code></pre><h2 id="class-coord" data-v-8d22b233>class Coord <a class="header-anchor" href="#class-coord" data-v-8d22b233>üîó</a></h2><p data-v-8d22b233>Cette classe sert √† identifier une case dans l&#39;aire de jeu ou dans un layer. Elle poss√®de deux variables membres <code data-v-8d22b233>x</code> et <code data-v-8d22b233>y</code>, de type <code data-v-8d22b233>int</code>.</p><h3 id="instanciation" data-v-8d22b233>Instanciation <a class="header-anchor" href="#instanciation" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>La classe peut √™tre instanci√©e en indiquant un X et un Y, ou une autre <code data-v-8d22b233>Coord</code>. Les objets <code data-v-8d22b233>Coord</code> peuvent √™tre compar√©s entre eux.</p><pre data-v-8d22b233><code data-v-8d22b233>coord_1 = squarity.Coord(5, 2)
coord_2 = squarity.Coord(coord=coord_1)
print(coord_1 == coord_2)
# La valeur &#39;True&#39; s&#39;affiche dans la console
</code></pre><h3 id="fonctions-de-base" data-v-8d22b233>Fonctions de base <a class="header-anchor" href="#fonctions-de-base" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>Les <code data-v-8d22b233>Coord</code> peuvent √™tre utilis√©es comme cl√©s dans un dictionnaire. Elles ont une repr√©sentation textuelle, ce qui permet de les √©crire avec un <code data-v-8d22b233>print</code>. Elles peuvent √™tre dupliqu√©es avec la m√©thode <code data-v-8d22b233>clone</code>.</p><pre data-v-8d22b233><code data-v-8d22b233>coord_1 = squarity.Coord(5, 2)
coord_2 = coord_1.clone()
print(coord_2)
# Le texte &quot;&lt;Coord 5, 2 &gt;&quot; s&#39;affiche dans la console
</code></pre><h3 id="fonctions-de-modification" data-v-8d22b233>Fonctions de modification <a class="header-anchor" href="#fonctions-de-modification" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>La m√©thode <code data-v-8d22b233>move_dir</code> permet de se d√©placer dans une direction donn√©e, sur une distance donn√©e (indiqu√©e par un <code data-v-8d22b233>int</code>). La distance par d√©faut est 1.</p><pre data-v-8d22b233><code data-v-8d22b233>coord_1 = squarity.Coord(5, 2)
coord_1.move_dir(squarity.dirs.Right, 2)
print(coord_1)
# Affichage de &quot;&lt;Coord 7, 2 &gt;&quot;
</code></pre><p data-v-8d22b233>La m√©thode <code data-v-8d22b233>move_by_vect</code> permet d&#39;appliquer un d√©placement, sp√©cifi√© par le param√®tre <code data-v-8d22b233>vector</code> (de type <code data-v-8d22b233>Coord</code>), ou sp√©cifi√© par les param√®tres <code data-v-8d22b233>x</code> et <code data-v-8d22b233>y</code>.</p><p data-v-8d22b233>Attention, il n&#39;y a pas de blocage sur les bords. Les mouvements peuvent amener une coordonn√©e en n√©gatif ou en dehors de l&#39;aire de jeu.</p><pre data-v-8d22b233><code data-v-8d22b233>coord_1 = squarity.Coord(5, 2)
coord_vect = squarity.Coord(0, -3)
coord_1.move_by_vect(vector=coord_vect)
coord_1.move_by_vect(x=1, y=-3)
print(coord_1)
# Affichage de &quot;&lt;Coord 6, -4 &gt;&quot;
</code></pre><h2 id="class-rect" data-v-8d22b233>class Rect <a class="header-anchor" href="#class-rect" data-v-8d22b233>üîó</a></h2><p data-v-8d22b233>D√©finit un rectangle √† partir de 4 param√®tres de type <code data-v-8d22b233>int</code> :</p><ul data-v-8d22b233><li data-v-8d22b233>X du coin sup√©rieur droit,</li><li data-v-8d22b233>Y du coin sup√©rieur droit,</li><li data-v-8d22b233>largeur,</li><li data-v-8d22b233>hauteur.</li></ul><p data-v-8d22b233>Les coordonn√©es dans le rectangle s&#39;√©tendent de X jusqu&#39;√† (X+largeur-1) en abscisse, et de Y jusqu&#39;√† (Y+hauteur-1) en ordonn√©e. C&#39;est le m√™me principe que la fonction python <code data-v-8d22b233>range</code>.</p><h3 id="fonction-in_bounds" data-v-8d22b233>Fonction in_bounds <a class="header-anchor" href="#fonction-in_bounds" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>Indique si une coordonn√©e se trouve √† l&#39;int√©rieur du rectangle.</p><pre data-v-8d22b233><code data-v-8d22b233>rect = squarity.Rect(5, 2, 3, 5)
print(rect.in_bounds(squarity.Coord(0, 0)))
# La valeur False s&#39;affichera dans la console.
print(rect.in_bounds(squarity.Coord(5, 4)))
# La valeur True s&#39;affichera dans la console.
</code></pre><h3 id="fonction-on_borders" data-v-8d22b233>Fonction on_borders <a class="header-anchor" href="#fonction-on_borders" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>Indique si une coordonn√©e se trouve sur un bord du rectangle.</p><pre data-v-8d22b233><code data-v-8d22b233>rect = squarity.Rect(5, 2, 3, 5)
for x in range(4, 10):
    coord_1 = squarity.Coord(x, 3)
    border = rect.on_border(coord_1)
    print(coord_1, &quot;est-elle au bord ?&quot;, border)
# Les informations suivantes vont s&#39;afficher:
# &lt;Coord 4, 3 &gt; est-elle au bord ? False
# &lt;Coord 5, 3 &gt; est-elle au bord ? True
# &lt;Coord 6, 3 &gt; est-elle au bord ? False
# &lt;Coord 7, 3 &gt; est-elle au bord ? True
# &lt;Coord 8, 3 &gt; est-elle au bord ? False
# &lt;Coord 9, 3 &gt; est-elle au bord ? False
</code></pre><h2 id="class-gameobject" data-v-8d22b233>class GameObject <a class="header-anchor" href="#class-gameobject" data-v-8d22b233>üîó</a></h2><p data-v-8d22b233>Un &quot;game object&quot; (ou gobj) est un √©l√©ment qui s&#39;affiche dans l&#39;aire de jeu. Un game object poss√®de des coordonn√©es et un nom de sprite (<code data-v-8d22b233>sprite_name</code>). Le nom de sprite correspond √† un nom r√©f√©renc√© dans le dictionnaire <code data-v-8d22b233>img_coords</code> de la config JSON.</p><p data-v-8d22b233>Pour que le game object s&#39;affiche, il doit √™tre plac√© dans un <code data-v-8d22b233>squarity.Layer</code>. Un game object peut √™tre transf√©r√© d&#39;un layer √† un autre. Il peut √©galement n&#39;appartenir √† aucun layer.</p><p data-v-8d22b233>Les coordonn√©es et le nom de sprite doivent √™tre sp√©cifi√©s d√®s l&#39;instanciation du game object. L&#39;ajout dans le layer peut √™tre effectu√© juste apr√®s (voir <a href="#class-layer" data-v-8d22b233>la classe squarity.Layer</a>).</p><pre data-v-8d22b233><code data-v-8d22b233>gobj = squarity.GameObject(squarity.Coord(5, 2), &quot;my_sprite&quot;)
print(gobj)
# Le texte &quot;&lt;Gobj (5,2) my_sprite&gt;&quot; s&#39;affiche dans la console.
</code></pre><p data-v-8d22b233>L&#39;instanciation poss√®de d&#39;autres param√®tres facultatifs. Ils sont d√©taill√©s plus loin dans cette doc.</p><h3 id="nom-du-sprite" data-v-8d22b233>Nom du sprite <a class="header-anchor" href="#nom-du-sprite" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>L&#39;aspect visuel du game object peut √™tre directement chang√© en modifiant la variable membre <code data-v-8d22b233>sprite_name</code>. La nouvelle image s&#39;affichera en fonction du tileset et de la config JSON.</p><p data-v-8d22b233>Attention, il n&#39;y a pas de v√©rification sur le nom du sprite. Si vous indiquez un nom qui n&#39;est pas r√©f√©renc√© dans <code data-v-8d22b233>config.img_coords</code>, le jeu va planter sans aucun message. (On am√©liorera √ßa dans les versions √† venir).</p><h3 id="coordonn√©es-acc√®s-et-modification" data-v-8d22b233>Coordonn√©es (acc√®s et modification) <a class="header-anchor" href="#coordonn√©es-acc√®s-et-modification" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>Le game object poss√®de une variable membre interne appel√©e <code data-v-8d22b233>_coord</code>. <strong data-v-8d22b233>Vous n&#39;√™tes pas cens√© y acc√©der directement</strong>, au risque de d√©sordonner l&#39;indexation des game objects dans les layers.</p><p data-v-8d22b233>Pour lire les coordonn√©es, utilisez la m√©thode <code data-v-8d22b233>coord_clone = gobj.get_coord()</code>. Si vous changez le contenu de la variable <code data-v-8d22b233>coord_clone</code>, vos modifications ne seront pas report√©es dans le game object.</p><p data-v-8d22b233>Pour d√©placer un game object, utilisez les m√©thodes <code data-v-8d22b233>move_xxx</code> :</p><ul data-v-8d22b233><li data-v-8d22b233><code data-v-8d22b233>move_to_xy</code> : d√©place l&#39;objet sur une case de destination, sp√©cifi√©e par les param√®tres X et Y (<code data-v-8d22b233>int</code>).</li><li data-v-8d22b233><code data-v-8d22b233>move_to</code> : d√©place l&#39;objet sur une case de destination, sp√©cifi√©e par le param√®tre <code data-v-8d22b233>dest_coord</code> (<code data-v-8d22b233>Coord</code>).</li><li data-v-8d22b233><code data-v-8d22b233>move</code> : d√©place l&#39;objet de mani√®re relative, selon un vecteur de d√©placement sp√©cifi√© par le param√®tre <code data-v-8d22b233>vector</code> (<code data-v-8d22b233>Coord</code>).</li><li data-v-8d22b233><code data-v-8d22b233>move_dir</code> : d√©place l&#39;objet de mani√®re relative, selon le param√®tre <code data-v-8d22b233>direction</code> (<code data-v-8d22b233>Direction</code>) et le param√®tre facultatif <code data-v-8d22b233>distance</code> (<code data-v-8d22b233>int</code>).</li></ul><pre data-v-8d22b233><code data-v-8d22b233>gobj = squarity.GameObject(squarity.Coord(5, 2), &quot;my_sprite&quot;)
gobj.move_to_xy(15, 9)
print(gobj)
# Affichage de &quot;&lt;Gobj (15,9) my_sprite&gt;&quot;.
gobj.move_to(squarity.Coord(7, 4))
print(gobj)
#   ---------&gt;        (7,4)
gobj.move(squarity.Coord(1, -1))
print(gobj)
#   ---------&gt;        (8,3)
gobj.move_dir(squarity.dirs.Right, 4)
print(gobj)
#   ---------&gt;        (12,3)
</code></pre><p data-v-8d22b233>Ces 4 fonctions laissent le game object dans le m√™me layer. Voir la documentation de la classe layer pour transf√©rer un game object d&#39;un layer √† un autre.</p><h3 id="transitions-ajout√©es-automatiquement" data-v-8d22b233>Transitions ajout√©es automatiquement. <a class="header-anchor" href="#transitions-ajout√©es-automatiquement" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>Lorsque vous d√©placez un game object, une &quot;transition&quot; est automatiquement affich√©e. Durant 200 millisecondes, le game object se d√©place progressivement (pixel par pixel) depuis sa case initiale vers sa case de destination.</p><p data-v-8d22b233>Ce d√©placement automatique est effectu√© en une seule ligne droite. Par exemple, si vous d√©placez un objet des coordonn√©es (5, 3) vers les coordonn√©es (8, 2), la ligne de d√©placement sera oblique.</p><p data-v-8d22b233>Si vous changez plusieurs fois les coordonn√©es dans un m√™me tour de jeu, la transition n&#39;utilisera pas les valeurs interm√©diaires. Les deux seules valeurs prises en compte sont celles avant et apr√®s l&#39;ex√©cution du code.</p><p data-v-8d22b233>Vous pouvez d√©clencher des transitions simultan√©es sur plusieurs game objects, en modifiant les coordonn√©es de chacun d&#39;entre eux.</p><p data-v-8d22b233>Il est possible de d√©finir des d√©placements avec des √©tapes interm√©diaires. Par exemple, un d√©placement horizontal de x=5 vers x=8, puis un vertical de y=3 vers y=2. <a href="#transitions" data-v-8d22b233>Voir &quot;Transitions&quot;</a>.</p><p data-v-8d22b233>Le temps de la transition peut √™tre red√©fini individuellement pour chaque game object, avec la fonction <code data-v-8d22b233>gobj.set_transition_delay(transition_delay)</code>. Le param√®tre <code data-v-8d22b233>transition_delay</code> est un <code data-v-8d22b233>int</code>, en millisecondes. Toutes les futures transitions dues √† un changement de coordonn√©es utiliseront ce nouveau temps.</p><p data-v-8d22b233>Les 4 fonctions <code data-v-8d22b233>move_xxx</code> poss√®dent un param√®tre facultatif <code data-v-8d22b233>transition_delay</code>, permettant de d√©finir un temps sp√©cifique uniquement pour la prochaine transition.</p><p data-v-8d22b233>Si transition_delay est d√©fini √† 0, l&#39;objet se d√©placera instantan√©ment.</p><h3 id="callback-de-fin-de-transition" data-v-8d22b233>Callback de fin de transition <a class="header-anchor" href="#callback-de-fin-de-transition" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>Il s&#39;agit d&#39;une fonction python que vous d√©finissez et que vous associez √† un game object. Elle sera automatiquement ex√©cut√©e chaque fois que le game object aura fini toutes ses transitions en cours. Pour associer une callback, utilisez la m√©thode <code data-v-8d22b233>gobj.set_callback_end_transi(callback_end_transi)</code>.</p><p data-v-8d22b233>Les callbacks ne peuvent pas avoir de param√®tre, mais vous pouvez indiquer une fonction ou une m√©thode d&#39;un objet sp√©cifique.</p><p data-v-8d22b233>Pour enlever une callback, ex√©cutez <code data-v-8d22b233>set_callback_end_transi</code> avec le param√®tre <code data-v-8d22b233>None</code>.</p><p data-v-8d22b233>Les 4 fonctions <code data-v-8d22b233>move_xxx</code> poss√®dent un param√®tre facultatif <code data-v-8d22b233>callback</code>, permettant de d√©finir une callback diff√©rente uniquement pour la prochaine transition.</p><pre data-v-8d22b233><code data-v-8d22b233>def my_callback():
    print(&quot;coucou&quot;)

gobj = squarity.GameObject(squarity.Coord(5, 2), &quot;my_sprite&quot;)
gobj.set_callback_end_transi(my_callback)
# (Cette exemple n&#39;affiche rien dans la console, d√©sol√©)
</code></pre><h2 id="class-layer" data-v-8d22b233>class Layer <a class="header-anchor" href="#class-layer" data-v-8d22b233>üîó</a></h2><p data-v-8d22b233>Un layer est un tableau en 2 dimensions, contenant des game objects. Votre aire de jeu peut contenir plusieurs layers, affich√©s dans un ordre d√©termin√©. Vous pouvez donc avoir un layer pour le d√©cor de fond, un pour les personnages et les bonus, un pour les √©l√©ments d&#39;interface, etc.</p><p data-v-8d22b233>L&#39;ordre d&#39;affichage des objets au sein d&#39;un layer n&#39;est pas d√©termin√©. Pour √™tre s√ªr de l&#39;ordre, vous devez utiliser plusieurs layers.</p><p data-v-8d22b233>Si l&#39;ordre importe peu, vous pouvez placer tous vos objets dans l&#39;unique layer cr√©√© par d√©faut : la variable membre <code data-v-8d22b233>layer_main</code>, dans le <code data-v-8d22b233>GameModel</code>.</p><h3 id="ajouter-et-retirer-des-game-objects" data-v-8d22b233>Ajouter et retirer des game objects <a class="header-anchor" href="#ajouter-et-retirer-des-game-objects" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>La m√©thode <code data-v-8d22b233>layer.add_game_object(gobj)</code> permet d&#39;ajouter un game object dans un layer. Les coordonn√©es du game object doivent √™tre d√©finies.</p><p data-v-8d22b233>La m√©thode <code data-v-8d22b233>layer.remove_game_object(gobj)</code> permet d&#39;enlever un game object d&#39;un layer. Une exception sera lev√©e si vous tentez d&#39;enlever un game object n&#39;appartenant pas au layer.</p><p data-v-8d22b233>La m√©thode <code data-v-8d22b233>layer.remove_at_coord(coord)</code> permet d&#39;enlever tous les game objects situ√©s aux coordonn√©es indiqu√©es en param√®tre.</p><p data-v-8d22b233>Apr√®s avoir √©t√© enlev√©, le game object existe toujours. Vous pouvez le r√©utiliser et le placer dans un autre layer.</p><p data-v-8d22b233>Ci-dessous, un exemple de code minimal affichant un seul objet immobile. Pour l&#39;ex√©cuter, s√©lectionnez le jeu d&#39;exemple de l&#39;√©meraude verte, supprimez tout le game code, puis copier-collez ce texte √† la place.</p><pre data-v-8d22b233><code data-v-8d22b233>import squarity

class GameModel(squarity.GameModelBase):
    def on_start(self):
        self.gobj = squarity.GameObject(squarity.Coord(5, 2), &quot;gem_green&quot;)
        self.layer_main.add_game_object(self.gobj)
</code></pre><h3 id="r√©cup√©rer-des-tiles-et-des-game-objects" data-v-8d22b233>R√©cup√©rer des tiles et des game objects <a class="header-anchor" href="#r√©cup√©rer-des-tiles-et-des-game-objects" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>Chaque √©l√©ment du tableau 2D d&#39;un layer est un objet <code data-v-8d22b233>squarity.Tile</code>, ils sont utiles pour se d√©placer dans un layer, gr√¢ce √† la variable <code data-v-8d22b233>adjacencies</code>. Il s&#39;agit d&#39;une liste de 8 √©l√©ments, contenant les tiles adjacentes. Certains de ces √©l√©ments peuvent √™tre <code data-v-8d22b233>None</code>, pour les tiles qui sont au bord.</p><p data-v-8d22b233>Les game objects d&#39;une tile sont stock√©s dans la variable membre <code data-v-8d22b233>game_objects</code> (de type <code data-v-8d22b233>list</code>).</p><p data-v-8d22b233>Les m√©thodes <code data-v-8d22b233>layer.get_tile(coord)</code> et <code data-v-8d22b233>layer.get_tile_xy(x, y)</code> permettent de r√©cup√©rer une tile.</p><p data-v-8d22b233>Ajoutez ce code apr√®s le code d&#39;exemple pr√©c√©dent pour tester une r√©cup√©ration de game object.</p><pre data-v-8d22b233><code data-v-8d22b233>        tile = self.layer_main.get_tile_xy(5, 1)
        tile_down = tile.adjacencies[int(squarity.dirs.Down)]
        print(&quot;Nombre d&#39;objets sur la tile :&quot;, len(tile_down.game_objects))
        print(tile_down.game_objects)
</code></pre><p data-v-8d22b233>La m√©thode <code data-v-8d22b233>layer.get_game_objects(coord)</code> permet de r√©cup√©rer directement tous les game objects situ√©s sur <code data-v-8d22b233>coord</code>.</p><p data-v-8d22b233>La m√©thode <code data-v-8d22b233>layer.iter_all_game_objects()</code> permet d&#39;it√©rer sur tous les game objects d&#39;un layer.</p><pre data-v-8d22b233><code data-v-8d22b233>        for gobj in self.layer_main.iter_all_game_objects():
            print(gobj)
</code></pre><h3 id="cr√©er-des-layers-et-les-ajouter-dans-le-jeu" data-v-8d22b233>Cr√©er des layers et les ajouter dans le jeu <a class="header-anchor" href="#cr√©er-des-layers-et-les-ajouter-dans-le-jeu" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>Les layers doivent √™tre plac√©s dans la liste <code data-v-8d22b233>layers</code> du <code data-v-8d22b233>GameModel</code>, cette liste contient initialement le <code data-v-8d22b233>layer_main</code>.</p><p data-v-8d22b233>L&#39;ordre dans <code data-v-8d22b233>layers</code> d√©termine l&#39;ordre d&#39;affichage. Le premier layer de la liste est dessin√© en premier et appara√Ætra donc en-dessous de tous les autres layers. Le dernier layer de la liste appara√Ætra au-dessus de tous les autres.</p><p data-v-8d22b233>Vous pouvez ajouter, enlever et r√©ordonner les layers dans la liste √† tout moment. Ce sera imm√©diatement pris en compte dans l&#39;affichage de l&#39;aire de jeu.</p><p data-v-8d22b233>Lors de l&#39;instanciation, un layer a besoin d&#39;avoir une r√©f√©rence vers le <code data-v-8d22b233>GameModel</code> dans lequel il est plac√©. Il faut √©galement sp√©cifier une largeur et une hauteur, en nombre de cases.</p><pre data-v-8d22b233><code data-v-8d22b233>class GameModel(squarity.GameModelBase):
    def on_start(self):
        layer_second = Layer(self, self.w, self.h)
        self.layers.append(layer_second)
</code></pre><p data-v-8d22b233>Tous les layers que vous placez dans <code data-v-8d22b233>layers</code> doivent avoir les m√™mes largeur et hauteur que votre aire de jeu. Ces dimensions sont d√©j√† initialis√©s dans le <code data-v-8d22b233>GameModel</code>, variables membres <code data-v-8d22b233>game_model.w</code> et <code data-v-8d22b233>game_model.h</code></p><p data-v-8d22b233>Pour g√©rer la logique interne de votre jeu, vous pouvez utiliser des layers de n&#39;importe quelles dimensions, que vous ne placerez pas dans <code data-v-8d22b233>layers</code>. Ils ne seront pas affich√©s.</p><p data-v-8d22b233>La fonction <code data-v-8d22b233>Layer.__init__</code> poss√®de un param√®tre facultatif <code data-v-8d22b233>show_transitions</code>, d√©fini √† True par d√©faut. Lorsqu&#39;il est d√©fini √† False, le layer ne g√®re aucune transition, ni pour les d√©placements d&#39;objets ni pour les modifications graphiques (scaling, d√©calage, ...). Lorsque vous changez les coordonn√©es d&#39;un objet dans un layer sans transition, il sera instantan√©ment d√©plac√© vers sa case de destination.</p><p data-v-8d22b233>Les layers sans transition sont g√©r√©s de mani√®re optimis√©e par le moteur Squarity, ils permettent des mouvements massifs et fr√©quents. Ils peuvent √™tre utiles, par exemple, pour afficher le d√©cor de fond de votre jeu, si ce d√©cor change d&#39;un seul coup d&#39;un niveau √† un autre.</p><p data-v-8d22b233>Le choix d&#39;avoir ou pas des transitions peut √™tre effectu√© uniquement √† l&#39;instanciation du layer. Si vous modifiez la variable <code data-v-8d22b233>layer.show_transitions</code> apr√®s l&#39;avoir cr√©√©, ce ne sera pas pris en compte par le moteur.</p><h3 id="class-layersparse" data-v-8d22b233>class LayerSparse <a class="header-anchor" href="#class-layersparse" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>Il s&#39;agit d&#39;une classe ayant le m√™me fonctionnement que la classe <code data-v-8d22b233>Layer</code> (les deux h√©ritent de <code data-v-8d22b233>LayerBase</code>). Les game objects contenus dans un <code data-v-8d22b233>LayerSparse</code> ne sont pas index√©s dans un tableau en deux dimensions, mais plac√©s dans une liste unique.</p><p data-v-8d22b233>L&#39;ajout, la suppression et le parcours d&#39;objets sont plus rapides avec un <code data-v-8d22b233>LayerSparse</code>, mais la r√©cup√©ration d&#39;objets √† une coordonn√©e sp√©cifique est plus lent.</p><p data-v-8d22b233>Si vous cr√©ez des jeux n&#39;ayant pas de gros besoins en performance, vous n&#39;avez pas besoin de vous soucier de ces d√©tails. Vous pouvez utiliser uniquement des classes <code data-v-8d22b233>Layer</code>, avec gestion des transitions.</p><p data-v-8d22b233>Liste des m√©thodes communes aux classes <code data-v-8d22b233>Layer</code> et <code data-v-8d22b233>LayerSparse</code> :</p><ul data-v-8d22b233><li data-v-8d22b233><code data-v-8d22b233>get_game_objects</code></li><li data-v-8d22b233><code data-v-8d22b233>iter_all_game_objects</code></li><li data-v-8d22b233><code data-v-8d22b233>add_game_object</code></li><li data-v-8d22b233><code data-v-8d22b233>remove_game_object</code></li><li data-v-8d22b233><code data-v-8d22b233>remove_at_coord</code></li><li data-v-8d22b233><code data-v-8d22b233>move_game_object</code></li><li data-v-8d22b233><code data-v-8d22b233>move_game_object_xy</code></li></ul><p data-v-8d22b233>Les m√©thodes <code data-v-8d22b233>get_tile</code> et <code data-v-8d22b233>get_tile_xy</code> ne sont pas pr√©sentes dans un <code data-v-8d22b233>LayerSparse</code>, puisqu&#39;il n&#39;y a pas de tableau en 2 dimensions contenant des tiles.</p><h2 id="class-gamemodel" data-v-8d22b233>class GameModel <a class="header-anchor" href="#class-gamemodel" data-v-8d22b233>üîó</a></h2><p data-v-8d22b233>Il s&#39;agit de la classe principale d√©finissant la logique de votre jeu. Elle h√©rite de <code data-v-8d22b233>GameModelBase</code>. Vous devez la d√©finir, mais pas l&#39;instancier, c&#39;est fait automatiquement par le moteur.</p><p data-v-8d22b233>Le game model sert √† d√©finir des fonctions de callback, qui seront automatiquement appel√©es sur certains √©v√©nements dans le jeu.</p><h3 id="liste-des-callbacks" data-v-8d22b233>Liste des callbacks <a class="header-anchor" href="#liste-des-callbacks" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233><code data-v-8d22b233>on_start(self)</code> : cette fonction est appel√©e une seule fois au d√©but du jeu. Il est conseill√© de mettre votre code d&#39;initialisation dans cette fonction plut√¥t que dans <code data-v-8d22b233>__init__</code>, car <code data-v-8d22b233>on_start</code> permet de renvoyer un objet <code data-v-8d22b233>EventResult</code>. <a href="#class-eventresult" data-v-8d22b233>Voir la classe &quot;EventResult&quot;</a></p><p data-v-8d22b233><code data-v-8d22b233>on_click(self, coord)</code> : cette fonction est appel√©e √† chaque clic de souris dans l&#39;aire de jeu. Le param√®tre <code data-v-8d22b233>coord</code> indique la case o√π le clic a eu lieu. Vous ne pouvez pas savoir pr√©cis√©ment quel Game Object a √©t√© cliqu√©, ni la position exacte du clic au pixel pr√®s, car le but de Squarity est de rester simple et de se sp√©cialiser dans les jeux en 2D sur un quadrillage.</p><p data-v-8d22b233>Dans l&#39;exemple ci-dessous, un diamant s&#39;ajoute sur chaque case que vous cliquez.</p><pre data-v-8d22b233><code data-v-8d22b233>import squarity

class GameModel(squarity.GameModelBase):
    def on_click(self, coord):
        if not self.layer_main.get_game_objects(coord):
            self.gobj = squarity.GameObject(coord, &quot;gem_yellow&quot;)
            self.layer_main.add_game_object(self.gobj)
</code></pre><p data-v-8d22b233><code data-v-8d22b233>on_button_direction(self, direction)</code> : cette fonction est appel√©e lorsque l&#39;un des 4 boutons de direction est cliqu√© ou que l&#39;une des 4 touches de direction du clavier est appuy√©e. Le param√®tre <code data-v-8d22b233>direction</code> est un objet de type <code data-v-8d22b233>Direction</code>.</p><p data-v-8d22b233>Dans l&#39;exemple ci-dessous, l&#39;aire de jeu affiche un diamant qui se d√©place en fonction des actions de la personne qui joue.</p><pre data-v-8d22b233><code data-v-8d22b233>import squarity

class GameModel(squarity.GameModelBase):

    def on_start(self):
        self.gobj = squarity.GameObject(squarity.Coord(5, 2), &quot;gem_green&quot;)
        self.layer_main.add_game_object(self.gobj)

    def on_button_direction(self, direction):
        coord_dest = self.gobj.get_coord().move_dir(direction)
        if self.rect.in_bounds(coord_dest):
            self.gobj.move_to(coord_dest)
</code></pre><p data-v-8d22b233><code data-v-8d22b233>on_button_action(self, action_name)</code> : cette fonction est appel√©e lorsque la personne qui joue d√©clenche l&#39;action &quot;1&quot; ou &quot;2&quot;, c&#39;est √† dire dans l&#39;un des cas suivants :</p><ul data-v-8d22b233><li data-v-8d22b233>un des boutons &quot;1&quot; ou &quot;2&quot; √† c√¥t√© des fl√®ches de direction a √©t√© cliqu√©.</li><li data-v-8d22b233>l&#39;une des touches du clavier &quot;1&quot; ou &quot;2&quot; au-dessus des lettres a √©t√© appuy√©e.</li><li data-v-8d22b233>l&#39;une tes touches &quot;1&quot; ou &quot;2&quot; du pav√© num√©rique a √©t√© appuy√©e.</li></ul><h3 id="variables-membres-de-gamemodel" data-v-8d22b233>Variables membres de GameModel <a class="header-anchor" href="#variables-membres-de-gamemodel" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>Elles sont initialis√©es d√®s le d√©part. Vous pouvez les lire mais vous ne devriez pas les modifier, car elles sont utilis√©es dans la librairie squarity.</p><ul data-v-8d22b233><li data-v-8d22b233><code data-v-8d22b233>self.w</code> : largeur de l&#39;aire de jeu, en nombre de case. (Correspond √† <code data-v-8d22b233>nb_tile_width</code> dans la config json)</li><li data-v-8d22b233><code data-v-8d22b233>self.h</code> : hauteur de l&#39;aire de jeu, en nombre de case. (Correspond √† <code data-v-8d22b233>nb_tile_height</code> dans la config json)</li><li data-v-8d22b233><code data-v-8d22b233>self.str_game_conf_json</code> : cha√Æne de caract√®re contenant la configuration json compl√®te.</li><li data-v-8d22b233><code data-v-8d22b233>self.rect</code> : objet <code data-v-8d22b233>Rect</code> ayant les dimensions de l&#39;aire de jeu, c&#39;est √† dire <code data-v-8d22b233>Rect(0, 0, self.w, self.h)</code>.</li><li data-v-8d22b233><code data-v-8d22b233>self.transition_delay</code> : d√©finit le temps par d√©faut (en millisecondes) de toutes les transitions effectu√©es suite √† un changement de coordonn√©es d&#39;un game object. Contrairement aux autres variables, celle-ci peut √™tre modifi√©e. <a href="#transitions" data-v-8d22b233>Voir &quot;Transitions&quot;</a></li></ul><h3 id="m√©thode-get_first_gobj" data-v-8d22b233>M√©thode get_first_gobj <a class="header-anchor" href="#m√©thode-get_first_gobj" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>La m√©thode <code data-v-8d22b233>self.get_first_gobj(coord, sprite_names, layer)</code> permet de r√©cup√©rer le premier game object pr√©sent dans l&#39;aire de jeu, selon diff√©rents crit√®res cumulables. Les 3 param√®tres sont facultatifs. Si aucun objet n&#39;est trouv√©, la m√©thode renvoie None.</p><ul data-v-8d22b233><li data-v-8d22b233>param√®tre <code data-v-8d22b233>coord</code> : par d√©faut, l&#39;objet est cherch√© sur toute l&#39;aire de jeu. Sinon, ce param√®tre peut √™tre un <code data-v-8d22b233>Rect</code> ou une <code data-v-8d22b233>Coord</code>, indiquant dans quelle zone ou sur quelles coordonn√©es on cherche l&#39;objet.</li><li data-v-8d22b233>param√®tre <code data-v-8d22b233>sprite_names</code> : par d√©faut, pas de filtre sur le nom de sprite. Sinon, ce param√®tre doit √™tre une liste de strings, indiquant le ou les noms de sprite recherch√©s.</li><li data-v-8d22b233>param√®tre <code data-v-8d22b233>layer</code> : par d√©faut, l&#39;objet est cherch√© dans tous les Layers de la liste <code data-v-8d22b233>self.layers</code>. Sinon, ce param√®tre doit √™tre un unique <code data-v-8d22b233>Layer</code>.</li></ul><h2 id="class-eventresult" data-v-8d22b233>class EventResult <a class="header-anchor" href="#class-eventresult" data-v-8d22b233>üîó</a></h2><p data-v-8d22b233>Cette classe regroupe des informations g√©n√©rales que vous pouvez communiquer au moteur du jeu, apr√®s l&#39;ex√©cution de n&#39;importe quelle fonction de callback (provenant du game model, d&#39;un game object ou de n&#39;importe quoi d&#39;autres).</p><p data-v-8d22b233>Par d√©faut, ces fonctions de callback ne renvoient rien (elles n&#39;ont pas d&#39;instruction <code data-v-8d22b233>return</code>). Dans ce cas, la valeur r√©ellement renvoy√©e est <code data-v-8d22b233>None</code>, mais vous pouvez renvoyer un objet <code data-v-8d22b233>EventResult</code> √† la place.</p><h3 id="callback-diff√©r√©e" data-v-8d22b233>Callback diff√©r√©e <a class="header-anchor" href="#callback-diff√©r√©e" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>Vous pouvez indiquer dans un <code data-v-8d22b233>EventResult</code> que le moteur doit ex√©cuter une de vos fonctions (une autre callback), apr√®s un d√©lai sp√©cifi√©.</p><p data-v-8d22b233>Instanciez une classe <code data-v-8d22b233>DelayedCallBack</code>, en indiquant le d√©lai d&#39;ex√©cution en millisecondes et la callback. Vous pouvez indiquer une fonction de votre code, une m√©thode de votre game model (<code data-v-8d22b233>self.my_callback</code>), une m√©thode d&#39;un game object sp√©cifique, etc. La callback ne peut pas avoir de param√®tres.</p><p data-v-8d22b233>Ajoutez ensuite cet objet <code data-v-8d22b233>DelayedCallBack</code> dans votre event result, avec la fonction <code data-v-8d22b233>event_result.add_delayed_callback</code>.</p><p data-v-8d22b233>Le code ci-dessous √©crit &quot;coucou&quot; dans la console apr√®s un temps d&#39;attente de 500 millisecondes.</p><pre data-v-8d22b233><code data-v-8d22b233>import squarity

def my_callback():
    print(&quot;coucou&quot;)

class GameModel(squarity.GameModelBase):
    def on_start(self):
        event_result = squarity.EventResult()
        event_result.add_delayed_callback(
            squarity.DelayedCallBack(500, my_callback)
        )
        return event_result
</code></pre><p data-v-8d22b233>C&#39;est un peu verbeux, on raccourcira ce code dans une version ult√©rieure de Squarity.</p><p data-v-8d22b233>Vous ne pouvez pas annuler une callback apr√®s l&#39;avoir renvoy√©e via un event result. C&#39;est √† vous de le g√©rer dans votre code.</p><p data-v-8d22b233>Il y a un bug : si vous red√©marrez votre jeu, ou m√™me si vous lancez un autre jeu, les callbacks du jeu pr√©c√©dent restent en m√©moire et sont tout de m√™me ex√©cut√©es. Ce sera corrig√© au plus vite.</p><h3 id="player-lock-plock-custom" data-v-8d22b233>Player Lock (plock) Custom <a class="header-anchor" href="#player-lock-plock-custom" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>Votre jeu aura peut-√™tre besoin d&#39;afficher des petites animations courtes, durant lesquelles la personne qui joue n&#39;est pas cens√©e agir. Il est possible d&#39;appliquer un &quot;Player Lock&quot;, c&#39;est √† dire de bloquer temporairement les boutons et les clics.</p><p data-v-8d22b233>Il y a deux types de Player Locks :</p><ul data-v-8d22b233><li data-v-8d22b233>custom : vous indiquez explicitement, dans votre code, √† quel moments se passent les locks et unlocks.</li><li data-v-8d22b233>transition : les locks/unlocks sont effectu√©s automatiquement d&#39;apr√®s les transitions de certains game objects (<a href="#blocage-de-linterface-player-lock-transi" data-v-8d22b233>Voir &quot;Player Lock Transi&quot;</a>).</li></ul><p data-v-8d22b233>Pour les locks custom, le blocage est toujours montr√© dans l&#39;interface : les boutons d&#39;actions apparaissent gris√©.</p><p data-v-8d22b233>Il est possible de locker/delocker avec plusieurs mots-cl√©s (chacun √©tant consid√©r√© comme une raison pour locker). L&#39;interface redevient active lorsqu&#39;il n&#39;y a plus aucun mot-cl√© de lock en cours.</p><p data-v-8d22b233>Pour locker : instanciez un <code data-v-8d22b233>EventResult</code> et ajoutez des strings dans la liste <code data-v-8d22b233>event_result.plocks_custom</code>, repr√©sentant les mot-cl√©s de lock. Pour enlever des locks : utilisez la liste <code data-v-8d22b233>event_result.punlocks_custom</code>.</p><p data-v-8d22b233>Attention, l&#39;interface est enti√®rement bloqu√©e d√®s le premier mot-cl√©. Il faut donc obligatoirement pr√©voir les unlocks en renvoyant des fonctions de callbacks en m√™me temps. Si ce n&#39;est pas fait, la personne qui joue restera bloqu√©e. Le bouton &quot;Ex√©cuter le jeu&quot; enl√®ve tous les locks, mais il r√©initialise tout le jeu au d√©but.</p><p data-v-8d22b233>Il est possible d&#39;enlever tous les mots-cl√©s de lock d&#39;un seul coup, en ajoutant le caract√®re <code data-v-8d22b233>&quot;*&quot;</code> dans <code data-v-8d22b233>punlocks_custom</code>.</p><p data-v-8d22b233>Le code ci-dessous locke l&#39;interface pendant 2 secondes √† chaque fois que l&#39;on clique dans l&#39;aire de jeu.</p><pre data-v-8d22b233><code data-v-8d22b233>import squarity

def callback_unlock():
    print(&quot;unlock&quot;)
    event_result = squarity.EventResult()
    event_result.punlocks_custom.append(&quot;*&quot;)
    return event_result

class GameModel(squarity.GameModelBase):
    def on_click(self, coord):
        print(&quot;lock&quot;)
        event_result = squarity.EventResult()
        event_result.plocks_custom.append(&quot;lock_a&quot;)
        event_result.plocks_custom.append(&quot;lock_b&quot;)
        event_result.add_delayed_callback(
            squarity.DelayedCallBack(2000, callback_unlock)
        )
        return event_result
</code></pre><h3 id="annuler-le-rendu-de-laire-de-jeu" data-v-8d22b233>Annuler le rendu de l&#39;aire de jeu <a class="header-anchor" href="#annuler-le-rendu-de-laire-de-jeu" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>Certaines actions de votre jeu (en particulier, les fonctions de callback contenant peu de code) ne modifient pas forc√©ment la disposition ou l&#39;√©tat des game objects. Dans ce cas, vous pouvez indiquer au moteur qu&#39;il n&#39;est pas n√©cessaire de redessiner l&#39;aire de jeu.</p><p data-v-8d22b233>Instancier un <code data-v-8d22b233>EventResult</code>, d√©finissez la variable <code data-v-8d22b233>redraw</code> √† False, puis renvoyez-le avec un <code data-v-8d22b233>return</code>.</p><pre data-v-8d22b233><code data-v-8d22b233>        event_result = squarity.EventResult()
        event_result.redraw = False
        return event_result
</code></pre><p data-v-8d22b233>√Ä noter que s&#39;il y a des transitions en cours, l&#39;aire de jeu est r√©guli√®rement redessin√©e pour les afficher. Le fait de renvoyer un event result annulant le rendu n&#39;emp√™che pas les autres √©v√©nements de faire leurs rendus √† eux.</p><p data-v-8d22b233>Vous pouvez cumuler plusieurs √©l√©ments dans le m√™me event result. Par exemple, vous pouvez d√©clarer plusieurs callbacks, locker l&#39;interface avec 3 mot-cl√©s, enlever 4 autres mot-cl√©s de locks, le tout en annulant le rendu.</p><h2 id="transitions" data-v-8d22b233>Transitions <a class="header-anchor" href="#transitions" data-v-8d22b233>üîó</a></h2><p data-v-8d22b233>Une transition repr√©sente la modification progressive d&#39;une variable d&#39;un game object, sur une p√©riode de temps d√©finie.</p><p data-v-8d22b233>Les coordonn√©es sont des variables transitionnables. L&#39;objet se d√©placera pixel par pixel de sa case de destination vers sa case d&#39;arriv√©e. Visuellement, les coordonn√©es de votre game object deviennent des valeurs d√©cimales, afin de le placer entre deux cases. Dans votre code python, les coordonn√©es restent des nombres entiers et passent directement de la valeur de d√©part √† la valeur d&#39;arriv√©e.</p><p data-v-8d22b233>Les variables permettant de d√©caler et agrandir l&#39;image d&#39;un game object sont elles aussi transitionnables, <a href="#class-componentimagemodifier" data-v-8d22b233>voir la classe ComponentImageModifier</a>.</p><p data-v-8d22b233>Le sprite name peut avoir des transitions, mais elles ne sont pas progressives. L&#39;image change d&#39;un seul coup. Il est possible d&#39;encha√Æner ces changements : une premi√®re image pendant 100 millisecondes, une deuxi√®me pendant les 100 millisecondes suivantes, etc.</p><p data-v-8d22b233>Il existe deux moyens pour d√©clencher une transition : modifier directement une variable transitionnable ou ex√©cuter la fonction <code data-v-8d22b233>game_object.add_transition</code>.</p><h3 id="modification-dune-variable-transitionnable" data-v-8d22b233>Modification d&#39;une variable transitionnable <a class="header-anchor" href="#modification-dune-variable-transitionnable" data-v-8d22b233>üîó</a></h3><h4 id="pour-les-coordonn√©es" data-v-8d22b233>Pour les coordonn√©es <a class="header-anchor" href="#pour-les-coordonn√©es" data-v-8d22b233>üîó</a></h4><p data-v-8d22b233>Il faut appeler une fonction <code data-v-8d22b233>move_to_xxx</code>. Le temps de la transition sera d√©termin√© automatiquement. Il prend la premi√®re valeur d√©finie parmi :</p><ul data-v-8d22b233><li data-v-8d22b233>le param√®tre optionnel <code data-v-8d22b233>transition_delay</code> de la fonction <code data-v-8d22b233>move_to_xxx</code>,</li><li data-v-8d22b233>le temps sp√©cifique au game object, d√©fini via la fonction <code data-v-8d22b233>game_object.set_transition_delay(transition_delay)</code>,</li><li data-v-8d22b233>la variable membre <code data-v-8d22b233>game_model.transition_delay</code> (initialis√©e √† 200 millisecondes, que vous pouvez modifier).</li></ul><h4 id="pour-le-sprite-name" data-v-8d22b233>Pour le sprite name <a class="header-anchor" href="#pour-le-sprite-name" data-v-8d22b233>üîó</a></h4><p data-v-8d22b233>Il suffit de changer directement la valeur dans le game object. La transition sera instantan√©e.</p><h3 id="fonction-add_transition" data-v-8d22b233>Fonction add_transition <a class="header-anchor" href="#fonction-add_transition" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>Cette fonction permet d&#39;ajouter une s√©quence, pouvant contenir plusieurs transitions, elle n√©cessite deux param√®tres :</p><ul data-v-8d22b233><li data-v-8d22b233>une cha√Æne d√©signant une variable membre (<code data-v-8d22b233>&quot;coord&quot;</code> ou <code data-v-8d22b233>&quot;sprite_name&quot;</code>),</li><li data-v-8d22b233>une liste contenant des tuples de d√©lais et de valeurs.</li></ul><p data-v-8d22b233>Avec <code data-v-8d22b233>&quot;coord&quot;</code>, les valeurs doivent √™tre des <code data-v-8d22b233>Coord</code>. Le Game Object se d√©placera vers ces coordonn√©es, les unes apr√®s les autres.</p><p data-v-8d22b233>Dans l&#39;exemple ci-dessous, apr√®s un clic dans l&#39;aire de jeu, le diamant vert se d√©place √† vitesse normale vers la coordonn√©e (3, 1), puis tr√®s rapidement vers (7, 1), puis lentement vers (5, 2).</p><pre data-v-8d22b233><code data-v-8d22b233>import squarity

class GameModel(squarity.GameModelBase):

    def on_start(self):
        self.gobj = squarity.GameObject(squarity.Coord(5, 2), &quot;gem_green&quot;)
        self.layer_main.add_game_object(self.gobj)

    def on_click(self, coord):
        self.gobj.add_transition(
            squarity.TransitionSteps(
                &quot;coord&quot;,
                (
                    (500, squarity.Coord(3, 1)),
                    (200, squarity.Coord(7, 1)),
                    (900, squarity.Coord(5, 2)),
                )
            )
        )
</code></pre><p data-v-8d22b233>Vous ne pouvez d√©finir que le temps de d√©placement, et non pas une vitesse g√©n√©rique. Par exemple, si vous souhaitez que votre game object se d√©place toujours √† la m√™me vitesse quel que soit la distance √† parcourir, vous allez devoir coder vous-m√™me le calcul des temps de d√©placement. (On fera mieux √† la prochaine version de Squarity).</p><p data-v-8d22b233>Lorsque le premier param√®tre de <code data-v-8d22b233>TransitionSteps</code> est <code data-v-8d22b233>&quot;sprite_name&quot;</code>, les valeurs doivent √™tre des strings correspondant √† des noms de sprites. Le game object changera successivement d&#39;apparence.</p><p data-v-8d22b233>Une transition est affich√©e progressivement, mais elle est appliqu√©e dans le jeu d√®s qu&#39;elle est d√©marr√©e. Pour les coordonn√©es, c&#39;est simple √† comprendre. Pour un sprite name, l&#39;image change d√®s le d√©but de la transition et reste telle quelle durant le temps indiqu√©. Donc pour une transition de sprite name, le dernier temps n&#39;est pas tr√®s utile et peut √™tre z√©ro.</p><p data-v-8d22b233>Dans le futur, on changera l&#39;ordre des param√®tres. D&#39;abord le sprite name, puis le temps. Ce sera plus logique √† comprendre.</p><p data-v-8d22b233>Si votre game object a une callback de fin de transition, d√©finie √† l&#39;aide de la fonction <code data-v-8d22b233>game_object.set_callback_end_transi</code>, cellec-ci sera d√©clench√©e √† la fin de la liste des transitions.</p><h3 id="encha√Ænement-des-transitions" data-v-8d22b233>Encha√Ænement des transitions <a class="header-anchor" href="#encha√Ænement-des-transitions" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>M√™me si des transitions sont en cours, vous pouvez en ajouter d&#39;autres via la m√©thode <code data-v-8d22b233>add_transition</code>. Elles vont s&#39;ajouter apr√®s les transitions existantes.</p><p data-v-8d22b233>La prise en compte des transitions par le moteur est effectu√©e √† la fin de l&#39;ex√©cution du code en cours (<code data-v-8d22b233>on_click</code>, <code data-v-8d22b233>on_button_xxx</code>, une callback, ...). Si vous ajoutez plusieurs transitions dans le m√™me code, elles seront d√©clench√©es au m√™me moment et seront ex√©cut√©es en m√™me temps. Cela permet d&#39;avoir un objet qui se d√©place tout en changeant de sprite.</p><p data-v-8d22b233>Dans votre game object, les variables membres <code data-v-8d22b233>coord</code> et <code data-v-8d22b233>sprite_name</code> changent automatiquement, au fur et √† mesure de l&#39;encha√Ænement des transitions. Ce changement n&#39;est pas progressif, il est appliqu√© au d√©but de chaque transition. Cela permet de garder des nombres entiers dans les coordonn√©es, m√™me si visuellement l&#39;objet s&#39;affiche entre les deux.</p><p data-v-8d22b233>Le moteur essaye, autant que faire se peut, d&#39;avoir le m√™me type de gestion pour les transitions ajout√©es suite √† une modification de variable et les transitions ajout√©es avec <code data-v-8d22b233>add_transition</code> :</p><ul data-v-8d22b233><li data-v-8d22b233>Durant une transition provenant d&#39;une modification de variable, la variable contient la valeur finale. C&#39;est normal, c&#39;est vous m√™me qui l&#39;avez d√©finie avec votre code python.</li><li data-v-8d22b233>Si vous remodifiez la variable pendant une transition, celle-ci va s&#39;encha√Æner apr√®s les transitions existantes. Le moteur utilise toujours la valeur finale de l&#39;encha√Ænement de transitions pour ajouter la prochaine.</li><li data-v-8d22b233>Durant les transitions provenant de <code data-v-8d22b233>add_transition</code>, c&#39;est le moteur du jeu qui modifie automatiquement la variable transitionn√©e. Cette modification se fait au d√©but de chaque transition, comme si c&#39;√©tait votre code qui le changeait manuellement, √† chaque fois que la transition pr√©c√©dente se termine.</li></ul><p data-v-8d22b233><strong data-v-8d22b233>Attention</strong> : il est fortement d√©conseill√© d&#39;avoir, sur un m√™me game object et √† un m√™me instant, des transitions provenant de modifications de variable et des transitions provenant de <code data-v-8d22b233>add_transition</code>. C&#39;est une situation ambig√ºe, dans laquelle on ne pourrait pas d√©terminer les valeurs des variables. Le moteur essaiera de le g√©rer comme il peut, c&#39;est √† dire pas tr√®s bien. Avant d&#39;ajouter de nouvelles transitions, vous devez donc vous assurer des transitions en cours et de leurs origines.</p><p data-v-8d22b233>Si vous avez des doutes, le plus simple est de s&#39;assurer qu&#39;il n&#39;y a aucune transition en cours sur un game object avant d&#39;effectuer des actions qui en ajouteraient. La m√©thode <code data-v-8d22b233>game_object.get_nb_undone_transitions()</code> renvoie le nombre de transitions restant √† effectuer. Si cette fonction renvoie 0, vous pouvez ajouter des transitions en toute s√©curit√© sur ce game object.</p><p data-v-8d22b233>Dans l&#39;exemple ci-dessous, lorsque vous appuyez sur un bouton de direction, le diamant se d√©place tout en clignotant (jaune-vert-jaune-vert). Lorsque vous cliquez, la console affiche son √©tat actuel : coordonn√©es, nom du sprite et nombres de transitions restantes. Appuyez plusieurs fois sur un bouton, puis cliquez √† fond dans le jeu pour avoir une d√©monstration de la mani√®re dont les transitions peuvent s&#39;accumuler.</p><pre data-v-8d22b233><code data-v-8d22b233>import squarity

class GameModel(squarity.GameModelBase):

    def on_start(self):
        self.gobj = squarity.GameObject(squarity.Coord(5, 2), &quot;gem_green&quot;)
        self.layer_main.add_game_object(self.gobj)

    def on_button_direction(self, direction):
        self.gobj.add_transition(
            squarity.TransitionSteps(
                &quot;coord&quot;,
                (
                    (500, squarity.Coord(3, 1)),
                    (200, squarity.Coord(7, 1)),
                    (900, squarity.Coord(5, 2)),
                )
            )
        )
        self.gobj.add_transition(
            squarity.TransitionSteps(
                &quot;sprite_name&quot;,
                (
                    (400, &quot;gem_yellow&quot;),
                    (400, &quot;gem_green&quot;),
                    (400, &quot;gem_yellow&quot;),
                    (0, &quot;gem_green&quot;),
                )
            )
        )

    def on_click(self, coord):
        print(&quot;Coordonn√©es:&quot;, self.gobj.get_coord())
        print(&quot;Nom du sprite:&quot;, self.gobj.sprite_name)
        print(&quot;Transitions restantes:&quot;, self.gobj.get_nb_undone_transitions())
</code></pre><h3 id="blocage-de-linterface-player-lock-transi" data-v-8d22b233>Blocage de l&#39;interface (Player Lock Transi) <a class="header-anchor" href="#blocage-de-linterface-player-lock-transi" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>Si une touche d&#39;action ou de direction reste appuy√©e, la fonction de callback correspondante sera ex√©cut√©e plusieurs fois tr√®s vite, ce qui peut poser probl√®me.</p><p data-v-8d22b233>Il est possible de bloquer automatiquement toute l&#39;interface du jeu (clics et boutons) tant qu&#39;un game object sp√©cifique a au moins une transition en cours. C&#39;est utile si votre jeu comporte un objet principal dirig√© par la personne qui joue. Si un bouton est appuy√© durant le mouvement de cet objet, ce ne sera pas pris en compte.</p><p data-v-8d22b233>Modifiez la variable membre <code data-v-8d22b233>plock_transi</code> de votre game object principal. Celle-ci peut prendre 3 valeurs:</p><ul data-v-8d22b233><li data-v-8d22b233><code data-v-8d22b233>PlayerLockTransi.NO_LOCK</code> : pas de blocage (valeur par d√©faut).</li><li data-v-8d22b233><code data-v-8d22b233>PlayerLockTransi.INVISIBLE</code> : blocage invisible. Les boutons ne changent pas d&#39;apparence, mais rien ne se passe si on clique dessus.</li><li data-v-8d22b233><code data-v-8d22b233>PlayerLockTransi.LOCK</code> : blockage visible. Les boutons s&#39;affichent en gris√©.</li></ul><pre data-v-8d22b233><code data-v-8d22b233>self.gobj = squarity.GameObject(squarity.Coord(5, 2), &quot;gem_green&quot;)
self.gobj.plock_transi = squarity.PlayerLockTransi.INVISIBLE
</code></pre><p data-v-8d22b233>Avec le blocage visible, les boutons d&#39;interface s&#39;affichent en gris√© pendant une fraction de seconde, √† chaque mouvement de l&#39;objet principal, ce qui peut √™tre d√©routant. C&#39;est pourquoi il vaut mieux utiliser un blocage invisible. Les blocages visibles sont utiles pour les animations narratives (les &quot;cut-scenes&quot;), ils permettent d&#39;indiquer explicitement que ce n&#39;est pas le moment de jouer.</p><p data-v-8d22b233>Les deux types de blocages ont exactement le m√™me effet, la diff√©rence est seulement visuelle.</p><p data-v-8d22b233>Les blocages &quot;Player Lock Transi&quot; sont appliqu√©s durant tous les types de transitions, aussi bien celles provenant d&#39;une modification de variable que celles ajout√©es avec <code data-v-8d22b233>add_transition</code>.</p><p data-v-8d22b233>Vous pouvez avoir plusieurs game objects bloquant l&#39;interface. Dans ce cas, l&#39;interface est utilisable lorsqu&#39;aucun de ces objets n&#39;a de transition en cours.</p><p data-v-8d22b233>Vous pouvez ajouter des transitions √† un objet bloquant m√™me s&#39;il a d√©j√† des transitions en cours.</p><h3 id="annuler-les-transitions-en-cours" data-v-8d22b233>Annuler les transitions en cours <a class="header-anchor" href="#annuler-les-transitions-en-cours" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>La m√©thode <code data-v-8d22b233>game_object.clear_transitions_to_record()</code> permet de supprimer les transitions que vous auriez ajout√©es via des m√©thodes <code data-v-8d22b233>add_transition</code>, <strong data-v-8d22b233>avant</strong> qu&#39;elles aient √©t√© prises en compte par le moteur du jeu.</p><p data-v-8d22b233>La m√©thode <code data-v-8d22b233>game_object.clear_all_transitions()</code> permet d&#39;annuler toutes les transitions prises en compte par le moteur. Dans le code, vous pouvez ex√©cuter cette fonction, puis ex√©cuter des <code data-v-8d22b233>add_transition</code>. Dans ce cas, les transitions pr√©c√©dentes seront toutes annul√©es, celles que vous avez ajout√©es seront prises en compte.</p><p data-v-8d22b233>Attention, si vous avez ajout√© un encha√Ænement de transition et que vous l&#39;annulez, la transition actuellement en cours est imm√©diatement termin√©e (l&#39;objet se d√©place instantan√©ment √† la destination de la transition). Les transitions qui n&#39;√©taient pas commenc√©es sont enti√®rement annul√©es.</p><p data-v-8d22b233>Pour essayer, remettez le code du chapitre &quot;Gestion des transitions&quot;, puis ajoutez ce code √† la fin:</p><pre data-v-8d22b233><code data-v-8d22b233>    def on_button_action(self, action_name):
        self.gobj.clear_all_transitions()
</code></pre><p data-v-8d22b233>Cliquez sur un bouton de direction, imm√©diatement apr√®s, cliquez sur un bouton d&#39;action (le &quot;1&quot; ou le &quot;2&quot;).</p><p data-v-8d22b233>Selon le moment o√π vous avez cliqu√©, le diamant s&#39;arr√™tera √† un endroit diff√©rent, il sera jaune ou vert.</p><h2 id="info-suppl√©mentaires-pour-les-sprites" data-v-8d22b233>Info suppl√©mentaires pour les sprites <a class="header-anchor" href="#info-suppl√©mentaires-pour-les-sprites" data-v-8d22b233>üîó</a></h2><p data-v-8d22b233>Chaque valeur du dictionnaire <code data-v-8d22b233>config.img_coords</code> (dans la config JSON) d√©finit un sprite. Elle est constitu√©e d&#39;une liste. Les deux premiers √©l√©ments sont obligatoires, les 3 suivants optionnels. Il s&#39;agit des √©l√©ments suivants :</p><ul data-v-8d22b233><li data-v-8d22b233><p data-v-8d22b233>Un nombre entier. Coordonn√©e x du coin sup√©rieur gauche de l&#39;image, dans le tileset. L&#39;unit√© est le pixel de tileset.</p></li><li data-v-8d22b233><p data-v-8d22b233>Coordonn√©e y du coin sup√©rieur gauche de l&#39;image.</p></li><li data-v-8d22b233><p data-v-8d22b233>Un nombre entier, par d√©faut : <code data-v-8d22b233>config.tile_size</code>. Largeur de l&#39;image prise dans le tileset. L&#39;unit√© est le pixel de tileset. La largeur et la hauteur ont une influence sur la taille de l&#39;image affich√©e dans l&#39;aire de jeu. Par exemple, si on indique une largeur qui vaut un tiers de <code data-v-8d22b233>config.tile_size</code>, l&#39;image affich√©e fera un tiers de case dans l&#39;aire de jeu.</p></li><li data-v-8d22b233><p data-v-8d22b233>Un nombre entier, par d√©faut : <code data-v-8d22b233>config.tile_size</code>. Hauteur de l&#39;image prise dans le tileset.</p></li><li data-v-8d22b233><p data-v-8d22b233>Une chaine de caract√®res qui vaut &quot;center&quot; ou &quot;corner_upleft&quot;, par d√©faut : &quot;corner_upleft&quot;. Indique o√π ancrer l&#39;image par rapport √† la case de l&#39;aire de jeu.</p><ul data-v-8d22b233><li data-v-8d22b233>&quot;corner_upleft&quot; : le coin haut gauche de l&#39;image reste fix√© sur le coin haut gauche de la case. Si on agrandit l&#39;image, elle va d√©passer vers le bas et vers la droite.</li><li data-v-8d22b233>&quot;center&quot; : le centre de l&#39;image reste fix√© sur le centre de la case. Si on agrandit l&#39;image, elle va d√©passer par les 4 c√¥t√©s.</li></ul></li></ul><p data-v-8d22b233>Voir sch√©ma dans le chapitre suivant (class <code data-v-8d22b233>ComponentImageModifier</code>).</p><h2 id="class-componentimagemodifier" data-v-8d22b233>class ComponentImageModifier <a class="header-anchor" href="#class-componentimagemodifier" data-v-8d22b233>üîó</a></h2><h3 id="initialisation" data-v-8d22b233>Initialisation <a class="header-anchor" href="#initialisation" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>Cette classe doit √™tre plac√©e dans un game object au moment de sa cr√©ation. Elle permet de modifier son affichage dans l&#39;aire de jeu.</p><p data-v-8d22b233>Si le <code data-v-8d22b233>ComponentImageModifier</code> est ajout√© apr√®s la cr√©ation du game object, il ne sera pas pris en compte. Il faut donc instancier votre game object comme ceci :</p><pre data-v-8d22b233><code data-v-8d22b233>gobj = squarity.GameObject(
    Coord(0, 0),
    &quot;gem_green&quot;,
    image_modifier=squarity.ComponentImageModifier()
)
</code></pre><h3 id="variables-membres" data-v-8d22b233>Variables membres <a class="header-anchor" href="#variables-membres" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>Toutes les variables commen√ßant par <code data-v-8d22b233>img_</code> repr√©sentent un nombre de pixels dans l&#39;image de tileset. Ce sont des nombres entiers, positifs ou n√©gatifs.</p><p data-v-8d22b233>Toutes les variables commen√ßant par <code data-v-8d22b233>area_</code> repr√©sentent un nombre de cases dans l&#39;aire de jeu. Ces nombres peuvent √™tre n√©gatifs, pour indiquer un sens inverse (vers le haut ou vers la gauche). Ils peuvent √™tre √©galement d√©cimaux, pour indiquer une fraction de case.</p><p data-v-8d22b233>Le <code data-v-8d22b233>ComponentImageModifier</code> poss√®de les variables suivantes :</p><ul data-v-8d22b233><li data-v-8d22b233><p data-v-8d22b233><code data-v-8d22b233>img_offset_x</code>, <code data-v-8d22b233>img_offset_y</code> : d√©calage, dans le tileset, de l&#39;image √† afficher. Modifier ces valeurs revient √† modifier, pour un seul game object, les 2 premi√®res valeurs du sprite name, dans <code data-v-8d22b233>config.img_coords</code>.</p></li><li data-v-8d22b233><p data-v-8d22b233><code data-v-8d22b233>img_size_x</code>, <code data-v-8d22b233>img_size_y</code> : taille, dans le tileset, de l&#39;image √† afficher. Modifier ces valeurs revient √† modifier, pour un seul game object, les 3√®me et 4√®me valeurs du sprite name, dans <code data-v-8d22b233>config.img_coords</code>. Par d√©faut, ces valeurs <code data-v-8d22b233>img_size</code> valent <code data-v-8d22b233>config.tile_size</code>.</p></li><li data-v-8d22b233><p data-v-8d22b233><code data-v-8d22b233>area_offset_x</code>, <code data-v-8d22b233>area_offset_y</code> : d√©calage, dans l&#39;aire de jeu, de l&#39;objet affich√©. Ces variables permettent d&#39;afficher un objet entre deux cases (m√™me si, dans la logique du jeu, l&#39;objet appartient toujours √† une seule case). Par exemple, si <code data-v-8d22b233>area_offset_x = -1.25</code>, l&#39;objet sera d√©cal√© vers la gauche, sur une distance de une case et un quart. L&#39;objet peut s&#39;afficher partiellement en dehors de l&#39;aire de jeu. Par d√©faut, ces valeurs <code data-v-8d22b233>area_offset</code> valent 0.0.</p></li><li data-v-8d22b233><p data-v-8d22b233><code data-v-8d22b233>area_scale_x</code>, <code data-v-8d22b233>area_scale_y</code> : facteur d&#39;√©chelle de l&#39;image affich√©e dans l&#39;aire de jeu. Par exemple, si <code data-v-8d22b233>area_scale_x = 2.5</code>, l&#39;image sera affich√©e 2,5 fois plus large que sa taille normale. Le positionnement de l&#39;image retaill√©e est d√©termin√©e √† l&#39;aide de l&#39;anchor (la valeur &quot;center&quot;/&quot;corner_upleft&quot; d√©finie dans <code data-v-8d22b233>config.img_coords</code>). Par d√©faut, ces valeurs <code data-v-8d22b233>area_scale</code> valent 1.0.</p></li></ul><p data-v-8d22b233>Ces 8 valeurs peuvent √™tre d√©finies lors de la cr√©ation du <code data-v-8d22b233>ComponentImageModifier</code> puis modifi√©es pendant le jeu. Le component se trouve dans la variable membre <code data-v-8d22b233>image_modifier</code> du game object.</p><p data-v-8d22b233>Dans l&#39;exemple ci-dessous, le diamant vert est affich√© de mani√®re √©cras√©e. Appuyez sur la fl√®che de gauche ou de droite pour l&#39;√©craser encore plus, appuyez sur la fl√®che du haut ou du bas pour l&#39;√©tirer.</p><pre data-v-8d22b233><code data-v-8d22b233>import squarity

d = squarity.dirs

class GameModel(squarity.GameModelBase):

    def on_start(self):
        self.gobj = squarity.GameObject(
            squarity.Coord(5, 2),
            &quot;gem_green&quot;,
            image_modifier=squarity.ComponentImageModifier(
                area_scale_x=2.0,
                area_scale_y=0.8,
            )
        )
        self.gobj.set_transition_delay(50)
        self.layer_main.add_game_object(self.gobj)

    def on_button_direction(self, direction):
        if direction in (d.Up, d.Down):
            if self.gobj.image_modifier.area_scale_x &gt; 0.1:
                self.gobj.image_modifier.area_scale_x -= 0.1
                self.gobj.image_modifier.area_scale_y += 0.1
        else:
            if self.gobj.image_modifier.area_scale_y &gt; 0.1:
                self.gobj.image_modifier.area_scale_y -= 0.1
                self.gobj.image_modifier.area_scale_x += 0.1
</code></pre><p data-v-8d22b233><img src="`+n+`" alt="Sch√©ma d√©crivant les informations que l&#39;on peut indiquer dans un &quot;image modifier&quot;" data-v-8d22b233></p><h3 id="transitions-1" data-v-8d22b233>Transitions <a class="header-anchor" href="#transitions-1" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>Les 8 valeurs du <code data-v-8d22b233>ComponentImageModifier</code> sont transitionnables, comme les coordonn√©es d&#39;un game object.</p><ul data-v-8d22b233><li data-v-8d22b233>Une simple modification de l&#39;une de ces valeurs d√©clenche une transition entre la valeur courante et la valeur finale, sur une dur√©e d√©finie via <code data-v-8d22b233>game_object.set_transition_delay</code>.</li><li data-v-8d22b233>Selon la valeur de <code data-v-8d22b233>game_object.plock_transi</code>, l&#39;interface peut √™tre lock√©e durant une transition.</li><li data-v-8d22b233>La fonction de callback de fin de transition du game object sera appel√©e, si elle est d√©finie.</li><li data-v-8d22b233>Il est possible d&#39;ajouter et d&#39;encha√Æner des s√©quences de transition avec la fonction <code data-v-8d22b233>gobj.image_modifier.add_transitions</code>.</li></ul><p data-v-8d22b233>L&#39;exemple ci-dessous effectue une petite animation avec le diamant vert. Cliquez dans l&#39;aire de jeu pour la d√©clencher.</p><pre data-v-8d22b233><code data-v-8d22b233>import squarity

class GameModel(squarity.GameModelBase):

    def on_start(self):
        self.gobj = squarity.GameObject(
            squarity.Coord(5, 2),
            &quot;gem_green&quot;,
            image_modifier=squarity.ComponentImageModifier()
        )
        self.layer_main.add_game_object(self.gobj)

    def on_click(self, coord):

        TRANSI_SCALE = (
            (150, 0.5), (150, 1.5), (150, 0.5), (150, 1.5),
            (150, 0.5), (150, 1.5), (150, 0.5), (150, 1.5),
            (150, 0.5), (150, 1.5),
            (150, 0.5), (75, 1),
        )
        self.gobj.image_modifier.add_transition(
            squarity.TransitionSteps(&quot;area_scale_x&quot;, TRANSI_SCALE)
        )
        self.gobj.image_modifier.add_transition(
            squarity.TransitionSteps(&quot;area_scale_y&quot;, TRANSI_SCALE)
        )

        self.gobj.image_modifier.add_transition(
            squarity.TransitionSteps(
                &quot;area_offset_x&quot;,
                ((200, -1), (400, -1), (400, 1), (400, 1), (400, -1), (200, 0))
            )
        )
        self.gobj.image_modifier.add_transition(
            squarity.TransitionSteps(
                &quot;area_offset_y&quot;,
                ((200, 1), (400, -1), (400, -1), (400, 1), (400, 1), (200, 0))
            )
        )
</code></pre><h2 id="class-componentbackcaller" data-v-8d22b233>class ComponentBackCaller <a class="header-anchor" href="#class-componentbackcaller" data-v-8d22b233>üîó</a></h2><p data-v-8d22b233>Cette classe doit √™tre plac√©e dans un game object, au moment de sa cr√©ation. Elle permet d&#39;ex√©cuter des callbacks au bout d&#39;un temps d√©fini. Il s&#39;agit du m√™me principe que les callbacks de <code data-v-8d22b233>EventResult</code>, mais associ√©es √† un game object.</p><p data-v-8d22b233>Si le game object est supprim√© ou s&#39;il est retir√© de son layer, les callbacks pr√©vues ne sont pas ex√©cut√©es.</p><p data-v-8d22b233>Lors de l&#39;instanciation du game object, d√©finisssez le param√®tre optionnel <code data-v-8d22b233>back_caller</code> avec <code data-v-8d22b233>ComponentBackCaller()</code>. Puis, ajoutez une callback avec <code data-v-8d22b233>back_caller.add_callback(delayed_callback)</code>.</p><p data-v-8d22b233>Contrairement aux autres transitions (coordonn√©es, sprite name, image modifier), lorsqu&#39;il n&#39;y a plus de callback √† ex√©cuter, celles du back_caller ne d√©clenche pas la callback de fin de transition du game object.</p><p data-v-8d22b233>En revanche, les callbacks ajout√©es dans le back_caller et qui n&#39;ont pas encore √©t√© ex√©cut√©es sont compt√©es par la fonction <code data-v-8d22b233>get_nb_undone_transitions</code>. (Note: et c&#39;est bizarre et on devrait avoir une fonction sp√©ciale pour renvoyer le nombre de callback restantes).</p><p data-v-8d22b233>Dans le code ci-dessous, le diamant vert ajoute deux callbacks d√®s le lancement du jeu. L&#39;une sera lanc√©e au bout de 2 secondes, l&#39;autre au bout de 4 secondes. Lorsque vous cliquez dans le jeu, le nombre de transitions restantes s&#39;affiche dans la console.</p><pre data-v-8d22b233><code data-v-8d22b233>import squarity

def my_callback():
    print(&quot;coucou de my_callback&quot;)

class GameModel(squarity.GameModelBase):

    def on_start(self):
        self.gobj = squarity.GameObject(
            squarity.Coord(5, 2),
            &quot;gem_green&quot;,
            back_caller=squarity.ComponentBackCaller()
        )
        self.layer_main.add_game_object(self.gobj)
        self.gobj.back_caller.add_callback(
            squarity.DelayedCallBack(2000, my_callback)
        )
        self.gobj.back_caller.add_callback(
            squarity.DelayedCallBack(4000, my_callback)
        )

    def on_click(self, coord):
        print(&quot;Transitions restantes:&quot;, self.gobj.get_nb_undone_transitions())
</code></pre><h2 id="it√©rer-dans-laire-de-jeu" data-v-8d22b233>It√©rer dans l&#39;aire de jeu <a class="header-anchor" href="#it√©rer-dans-laire-de-jeu" data-v-8d22b233>üîó</a></h2><p data-v-8d22b233>Il est tr√®s souvent n√©cessaire de parcourir tout ou une partie de l&#39;aire de jeu, pour rechercher des game objects sp√©cifiques. La classe <code data-v-8d22b233>Sequencer</code> permet d&#39;effectuer les it√©rations les plus communes.</p><p data-v-8d22b233>Cette classe contient uniquement des fonctions statiques, vous n&#39;avez pas besoin de l&#39;instancier.</p><p data-v-8d22b233>La fonction <code data-v-8d22b233>Sequencer.seq_iter</code> renvoie un it√©rateur. Les param√®tres de cette fonction sont des &quot;mini-it√©rateurs&quot; mis bout √† bout. Selon ces param√®tres, votre s√©quenceur renverra des coordonn√©es, des game objects ou des listes de game objects.</p><p data-v-8d22b233>Les mini-it√©rateurs sont cr√©√©s √† l&#39;aide d&#39;autres fonctions statiques du s√©quenceur.</p><h3 id="it√©rer-sur-des-coordonn√©es" data-v-8d22b233>It√©rer sur des coordonn√©es <a class="header-anchor" href="#it√©rer-sur-des-coordonn√©es" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>Le s√©quenceur permet d&#39;√©viter deux it√©rations imbriqu√©es sur x et sur y. Il n√©cessite un seul param√®tre, renvoy√© par <code data-v-8d22b233>Sequencer.iter_on_rect(rect, instanciate_coord=False)</code>.</p><p data-v-8d22b233>Le param√®tre <code data-v-8d22b233>rect</code> est un objet <code data-v-8d22b233>Rect</code>. Le param√®tre <code data-v-8d22b233>instanciate_coord</code> est un bool√©en. Lorsqu&#39;il vaut True, l&#39;it√©rateur recr√©e un nouvel objet <code data-v-8d22b233>Coord</code> √† chaque it√©ration. C&#39;est n√©cessaire dans une situation o√π vous auriez besoin de modifier temporairement les coordonn√©es sur lesquelles vous it√©rez.</p><p data-v-8d22b233>L&#39;exemple ci-dessous remplit l&#39;aire de jeu avec une alternance de diamant vert et de diamant jaune, pour cr√©er une sorte d&#39;√©chiquier.</p><pre data-v-8d22b233><code data-v-8d22b233>import squarity
S = squarity.Sequencer

def get_chessed_gem(coord):
    chessed_gems = [&quot;gem_yellow&quot;, &quot;gem_green&quot;]
    chess_index = (coord.x + coord.y) % 2
    return chessed_gems[chess_index]

class GameModel(squarity.GameModelBase):

    def on_start(self):
        seq = S.seq_iter(S.iter_on_rect(self.rect))
        for coord in seq:
            sprite_name = get_chessed_gem(coord)
            self.gobj = squarity.GameObject(coord, sprite_name)
            self.layer_main.add_game_object(self.gobj)
</code></pre><h3 id="it√©rer-sur-des-game-objects" data-v-8d22b233>It√©rer sur des Game Objects <a class="header-anchor" href="#it√©rer-sur-des-game-objects" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>Avec un deuxi√®me param√®tre, le s√©quenceur permet d&#39;it√©rer sur les game objects d&#39;un ou plusieurs layers.</p><p data-v-8d22b233><code data-v-8d22b233>Sequencer.gobj_on_layers(layers)</code> renverra les game objects les un apr√®s les autres. Le param√®tre <code data-v-8d22b233>layers</code> est la liste de layers dans laquelle on les recherche. L&#39;it√©ration est effectu√©e sur le rectangle sp√©cifi√© par <code data-v-8d22b233>iter_on_rect</code>.</p><p data-v-8d22b233><code data-v-8d22b233>Sequencer.gobj_on_layers_by_coords(layers)</code> renverra des listes de game objects, en les groupant par coordonn√©es. Les coordonn√©es n&#39;ayant aucun game objects g√©n√©reront des listes vides.</p><p data-v-8d22b233>Le troisi√®me param√®tre du s√©quenceur permet de filtrer sur des noms de sprites sp√©cifique: <code data-v-8d22b233>Sequencer.filter_sprites(sprite_names, skip_empty_lists=False)</code>.</p><ul data-v-8d22b233><li data-v-8d22b233>Le param√®tre <code data-v-8d22b233>sprite_names</code> est une liste de strings.</li><li data-v-8d22b233>Le param√®tre <code data-v-8d22b233>skip_empty_lists</code> est utile avec la fonction <code data-v-8d22b233>gobj_on_layers_by_coords</code>, il permet de passer les cases ne contenant aucun game objects.</li></ul><p data-v-8d22b233>L&#39;exemple ci-dessous place un diamant vert sur une case et deux diamants verts + un diamant jaune sur une autre. Chaque bouton de direction effectue une it√©ration sp√©cifique et logge les infos dans la console.</p><ul data-v-8d22b233><li data-v-8d22b233>La fl√®che du haut it√®re sur tous les Game Objects.</li><li data-v-8d22b233>La fl√®che du bas it√®re sur les listes de Game Objects (le log est moche mais c&#39;est pas grave).</li><li data-v-8d22b233>La fl√®che de gauche it√®re sur les diamants verts.</li><li data-v-8d22b233>La fl√®che de gauche it√®re sur les listes de diamant verts, en passant les cases qui n&#39;en contiennent pas.</li></ul><pre data-v-8d22b233><code data-v-8d22b233>import squarity
S = squarity.Sequencer

class GameModel(squarity.GameModelBase):

    def on_start(self):
        self.layer_other = squarity.Layer(self, self.w, self.h)
        self.layers.append(self.layer_other)
        self.layer_main.add_game_object(
            squarity.GameObject(squarity.Coord(5, 2), &quot;gem_green&quot;)
        )
        self.layer_main.add_game_object(
            squarity.GameObject(squarity.Coord(2, 4), &quot;gem_yellow&quot;)
        )
        self.layer_other.add_game_object(
            squarity.GameObject(squarity.Coord(2, 4), &quot;gem_green&quot;)
        )
        self.layer_other.add_game_object(
            squarity.GameObject(squarity.Coord(2, 4), &quot;gem_green&quot;)
        )

    def on_button_direction(self, direction):
        print(&quot;#&quot; * 20)
        if direction == squarity.dirs.Up:
            for gobj in S.seq_iter(
                S.iter_on_rect(self.rect),
                S.gobj_on_layers(self.layers)
            ):
                print(gobj)
        elif direction == squarity.dirs.Down:
            print(*S.seq_iter(
                S.iter_on_rect(self.rect),
                S.gobj_on_layers_by_coords(self.layers)
            ))
        elif direction == squarity.dirs.Left:
            for gobj in S.seq_iter(
                S.iter_on_rect(self.rect),
                S.gobj_on_layers(self.layers),
                S.filter_sprites([&quot;gem_green&quot;])
            ):
                print(gobj)
        elif direction == squarity.dirs.Right:
            for game_objects in S.seq_iter(
                S.iter_on_rect(self.rect),
                S.gobj_on_layers_by_coords(self.layers),
                S.filter_sprites([&quot;gem_green&quot;], True)
            ):
               print(*game_objects)
</code></pre><h3 id="r√©cup√©rer-le-premier-game-object" data-v-8d22b233>R√©cup√©rer le premier Game Object <a class="header-anchor" href="#r√©cup√©rer-le-premier-game-object" data-v-8d22b233>üîó</a></h3><p data-v-8d22b233>Il est possible de r√©cup√©rer directement le premier √©l√©ment renvoy√© par un s√©quenceur, au lieu d&#39;it√©rer avec. Pour cela, utilisez la fonction <code data-v-8d22b233>Sequencer.seq_first</code> √† la place de <code data-v-8d22b233>Sequencer.seq_iter</code>. Le fonctionnement des param√®tres est le m√™me. La fonction <code data-v-8d22b233>seq_first</code> it√®re une seule fois sur la s√©quence que vous avez fournie et renvoie le premier √©l√©ment. Si l&#39;it√©ration est vide, la fonction renvoie <code data-v-8d22b233>None</code>.</p><p data-v-8d22b233>Pour information, la fonction <code data-v-8d22b233>GameModel.get_first_gobj</code> utilise un s√©quenceur.</p><h2 id="exemple-bonus--afficher-tous-les-sprites-existants" data-v-8d22b233>Exemple bonus : afficher tous les sprites existants <a class="header-anchor" href="#exemple-bonus--afficher-tous-les-sprites-existants" data-v-8d22b233>üîó</a></h2><p data-v-8d22b233>Attention, cet exemple n&#39;utilise pas le jeu des diamants. Vous devez s√©lectionner le jeu d&#39;exemple H2O. C&#39;est plus amusant ainsi, car H2O contient beaucoup d&#39;images.</p><p data-v-8d22b233>Dans la config, modifier l&#39;information <code data-v-8d22b233>version</code> de &quot;1.0.0&quot; vers &quot;2.1.0&quot;.</p><p data-v-8d22b233>Ensuite, supprimez le code existant et remplacez-le par celui-ci:</p><pre data-v-8d22b233><code data-v-8d22b233>import json
import squarity

class GameModel(squarity.GameModelBase):

    def on_start(self):
        game_conf = json.loads(self.str_game_conf_json)

        seq = squarity.Sequencer.seq_iter(
            squarity.Sequencer.iter_on_rect(self.rect)
        )
        for coord, sprite_name in zip(seq, game_conf[&quot;img_coords&quot;].keys()):
            self.layer_main.add_game_object(
                squarity.GameObject(coord, sprite_name)
            )
</code></pre><p data-v-8d22b233>Vous verrez tous les sprites du jeu affich√© les uns apr√®s les autres dans l&#39;aire de jeu.</p><p data-v-8d22b233>Cet exemple de code fonctionne avec tous les jeux (√† condition de les mettre en version 2). Il peut √™tre utile si vous voulez v√©rifier que vous avez bien d√©fini toutes les coordonn√©es de tous les noms de sprites.</p>`,312)])])}const p=a(r,[["render",c],["__scopeId","data-v-8d22b233"]]);export{p as default};
