import{_ as t,o as a,c as n,e as o}from"./index-86c22afc.js";const s="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABACAMAAADS6oI8AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAwUExURQBxAI6Ojmtra0xMTAAAAAA+ADg4OJslAEcDAGgRACgoKP+bABgRd//bKzcm/wAAAJ3PoKoAAAAQdFJOU////////////////////wDgI10ZAAAACXBIWXMAAA6/AAAOvwE4BVMkAAACbUlEQVRYR72WC3IjIQxEE7uSdTbO+v63jVo0AwLBiATvq/IMIql+CPyZlzNeL1OujxMYY3jjXblMDdd35gyRCJPXcZkZru8RQcYXSczQIPkQ/BliBQ30adAAyVfB7cZAg8yOBHUvuwTDg4gIhvQd9J6A4GNIL2gQX7CDD11xRiqdoMDZnjL1EwGKWjAlKqiRA/YEedW2ofUO0nB7B7gozLeCwSngFRUcoEKJW99Bb1rsgPkcQOAs3rAmOPKLIDMSRQUJDDnGqBZUGNdKB8wv1yIYb9SCoM5vBRWNKyrgppS3E4pO0DfyFu7ArH/WQYaycAe4lvyAgIQ7kO+fsj+CI3BPOi6o1z/twHoCAi7ZgQJNdJcvk8EOfPwOLBHB8lMFyB1tFRzbVO0X8hHk8VdeEAypBO4RgEm+GiRjCmN6ji2a5MPAnCGMKbStTPPFwJwhL7w/jSXBJ2EZohHcBQ4PvgjTFU598V8mWMH9n9AaUorm6qgargo0vzNoypGeYLkoYH5rkJQcj6WX4VYBBikesNom0MQcfIzWBaMzyPmpBNmwUWDyWa4LkqHJl5x8qXAnPawAhjZfY/oof7bHbtEdLTQG7gargzR7bqgEmg6swc8fzzcUQY7/DwJr2CTA/lCBEWfBLgFS1aC3yrBHkDIpkPsTBIgsgsqw522afsgQnAwlP0exOPBne/IZKOjDbI+iMW2WO+nhCFrDxi87XX1n2Pp1jeh2k/b94HDtnkCjEZxgtS7Q5F6QDVTkof7pjJhAk1OVYP0jQX/IekUkHWW4JMg/NrwV+JT460dHPJbiE8ybB9PNZp1Rb9ETeDy+Aa1v47ca1zD2AAAAAElFTkSuQmCC",u="/assets/tuto_screenshot_01-7bdfd410.png",r="/assets/annotations_code-0b49074b.png",i="/assets/schema_self_tiles-3207e9ac.png",d="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIkAAABgBAMAAADbQUywAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAeUExURQBxAAA+AI6Ojmtra0xMTDg4OJslAEcDAGgRACgoKAn5SOEAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAHGSURBVFjD7VhLboMwFHzUPYClHqE3KBygi7InCxa5gPEJcgQry25639IAxZ/nD/aLxMITCemRaDLjh+3BAA2YyK9LmUzwwhrKBXGq+iQjY+vJrmnQgOn0aE0HzWhTVJd2+pyTsXAe0JkqlMKte5k1UOmhApmIwk5x/QbPqZ8BkseP59dIWViXz23aDemlNfEJx7C4Y+8GSzdY3wNeW9LYh8HSD1lLJmt1Md04gNCBMzkiWdt97ehnlun2zzHdAqb0P0hnCeUXl8V1FM8vLstdh0+IRYtpUYsOJYVIzC9+Fjl/BKTlF4xlMaMmuXUah5ZHvFqkEFJ/XoIj42WZL/eQFiOPeB3NUlaWhPzi06KWHjm/R0uH5bKwyK1HafnF40g9rquWeH7BHUmzR2AOh0uNs6jNFiYFyS+4o78G7Y5cKXYeecO0LFIeWtLyC6rlQWCPCwS2aHRcpnUqheeRRurtkaElll8SV6lIfomsmIn55dAe4DV1hMWfX1jbjzuu+K4WzS+s00jG8WeAnPzCeoPlOsQcoHdeRxPfyQyUKEp353zlq+cvftTzF2rU85eE/JJd05mq5y8o6vlLCCSPXz1/eSKyRwPgF3riJqFG0nECAAAAAElFTkSuQmCC",l="/assets/tuto_screenshot_level_map-91c23438.png",p="/assets/goldfish-50cb2e17.png",c="/assets/tuto_move_border-332059b7.png",v="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAP4AAACICAMAAADwM6a/AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAYUExURQAAAP88Jv/Z1P91a/+cjP/BuH1MRQAAADroIPEAAAAIdFJOU/////////8A3oO9WQAAAAlwSFlzAAAOwwAADsMBx2+oZAAABPhJREFUeF7tl+uaozgMRGezPd3v/8ZLqUqxfIFAEkLvZ50fQbZloeMhTOfPz9Sk/syk/syk/syk/syk/syk/syk/syk/syk/mf5x9DgclL/U1AcaOIXkPrnQ+nb7V8j9X8Np+vX6l9fRR7zCi8j9c8Dgl9fRR3cbph1lHgZqX8GlLstRHXIY4bxb/gapP67MfOBevs1gDJzgTZ/mNR/HxTxR7yIgn4GuRxfJZ/6ur4MZKANatF+hnAWUepfxFv0oR41H6nXc9fJp76uT0N1SKyBn7jmaVBdA0Nphop+jNR/BbTsArIRY8VeHl8PcsWXIPWfRUYLrdJfw2djXD/q/gokqf9xntaXwf2Rh148BDuBRdvjssoRD4LaHKnwR0n945j3AtouQAtAyWfqmBFgHmMVe5O+ilVoaUDqH4MF2Tge6CJI7ASCalxts33EY3r15cfO/IeXH6sWV0j9/bCgdR5A4wrFuj4/21UeGUaor5sdwNpa+nLx/V+o1N8LyqF0DVuPkiAKOpxFtq9zlrAKD+DIETCf6qzkY0RKWiX198CSBE06PsPmOSJR0NVsYYEj4NW0oF24274jQF770OOK8Z4Kqf8IL+m0zTr1ATDmJ/RBvd6P4gzuqgZW8L6iuh8GY6L0Iam/DQqg+IjYLohKiIGGC1Hf+mpAtkK7IyO10YG1Vh2joq7ETVJ/C5RB+THmZ2giHAiiuAI4st6qqvpuiLhqqZ0IZ6HqWea9EI9AyZuk/joowhuMcblamuA/wzgGqMeKMr1TVgFGBU3edRD7Y4/YfEPMSMkPSP11tuVH2vEKrfj4oylczdeEAWKsAE0NUYpR6/rLLh4JkcYGqb/GI/mIa/pnkfYI7dTqjMur7sj9uKfoMvaDkMAOUn8MyuheO6AwPoEmDYy8FmRtcqEW92gvFB6pH5FPfV07jrVDSQ0q+Idsrw55FydaPAB3Ud3Han8nqT+ChSPf3wru9A2PFFCJuprQY88VruGqxcNQ3UoFpPGQ1B/RttPLg75pzvD1N3rsywhriF+TL6BK1K5Ha6R+D7ayqGuP9XlThUYc8xBqoPt+dQfVCpLZJPV7YkvfhgYD2vbrcX0AEPYMPwZbOER/x0iZoYlHY1K/BRus7p0jB1Dv7h9/gqz2Lo/A4cV9+LnLSvjDp8bSDEmtkPotvTw/146gzX+kr74atLgK5LG3/PPg2soWPGP7AFK/pW5lJM2yGthIoRFH44e/zgf9DIByAVneoecj4hFw3IOM9SNI/Za6lfVHvuTVO+Jo+9VX7yvItwLZatAouxGNXn8O14G2BlK/Zq2lHhT0iFdSRkVeDnc4WyoUlNCATDV4p9+NmR6lD0n9mr6hdVCcVxuKvUo8BM/W1JB1CawQVilwVmmrpH5NX2gLZtd7/Mfse9gjAcy2QgubpH7NUX3kn6e/V+NZUr/mmD7Vz9GH+rnyqa+rwA1lsZNWHxXU/0ugjpo6kdSPHJWnbq2v/p+GFdXQyaR+BDeWh7BeDE001CsYyeIpsP9T6iD1a9hA1FZnS2tyrECGwpfksfeT4iT1W9jImohMBTNLrKSDWJGPq4PUb2Ez6qyDqg5z/5/qIPVHsCmiPoW8hVIWtHwI7tQtLyH1t2GLjrdckMlBtPlSdZD6+1HPb0ElLyb1Zyb1Zyb1Zyb1Zyb1Zyb1Zyb1Zyb1Zyb1Zyb1Z2Zq/Z+f/wBIogCSkt+SYgAAAABJRU5ErkJggg==",q="/assets/tuto_screenshot_final-f73a5076.png";const b={},m={class:"doc-article"};function g(f,e){return a(),n("div",m,[...e[0]||(e[0]=[o('<h1 id="tutoriel-soko-ban-v1" data-v-9603b154>Tutoriel Soko-ban (V1) <a class="header-anchor" href="#tutoriel-soko-ban-v1" data-v-9603b154>üîó</a></h1><p data-v-9603b154>Ce tutoriel vous permet de cr√©er un petit jeu simple avec la version V1 de Squarity. Il s&#39;agit d&#39;un <a href="https://fr.wikipedia.org/wiki/Sokoban" data-v-9603b154>soko-ban</a>, un jeu dans lequel un personnage doit pousser des caisses pour les ranger.</p><p data-v-9603b154>Squarity utilise le langage de programmation python et le format de description de donn√©es JSON. Vous n&#39;avez pas besoin de conna√Ætre ces notions, mais √ßa peut aider. Si vous souhaitez d√©couvrir ou approfondir ces sujets, voici <a href="https://python.developpez.com/cours/" data-v-9603b154>un lien vers des cours de python</a>, et la <a href="https://fr.wikipedia.org/wiki/JavaScript_Object_Notation" data-v-9603b154>la page Wikipedia sur le JSON</a>.</p><p data-v-9603b154>Ce tutoriel est un peu long, mais chacune des √©tapes que vous effectuez vous r√©compense par un r√©sultat visible dans l&#39;interface de jeu, ce qui permet de garder le courage de continuer.</p><h2 id="le-tileset" data-v-9603b154>Le tileset <a class="header-anchor" href="#le-tileset" data-v-9603b154>üîó</a></h2><p data-v-9603b154>Pour commencer, il faudrait dessiner un &quot;tileset&quot;, c&#39;est √† dire une image contenant tous les √©l√©ments affich√©s dans votre jeu.</p><p data-v-9603b154>En voici un d√©j√† pr√™t :</p><p data-v-9603b154><img src="'+s+`" alt="https://raw.githubusercontent.com/darkrecher/squarity-doc/master/user_manual/sokoban_tileset.png" data-v-9603b154></p><p data-v-9603b154>Il comporte 5 images d&#39;objets :</p><ul data-v-9603b154><li data-v-9603b154>un sol avec de l&#39;herbe</li><li data-v-9603b154>un mur</li><li data-v-9603b154>une caisse</li><li data-v-9603b154>le personnage</li><li data-v-9603b154>une cible, repr√©sentant un endroit o√π placer une caisse.</li></ul><p data-v-9603b154>Ce tileset comporte des pixels transparents. Si vous cr√©ez le v√¥tre, vous aurez peut-√™tre besoin d&#39;un logiciel g√©rant la transparence (donc, quelque chose de mieux que Paint).</p><p data-v-9603b154>Le tileset doit √™tre publi√© sur internet et vous devez conna√Ætre son url. Vous pouvez utiliser pour cela des sites d&#39;h√©bergement d&#39;images, comme https://imgbb.com/ . Lorsque l&#39;image est publi√©e, vous devez r√©cup√©rer l&#39;url directe vers le fichier. En g√©n√©ral, c&#39;est possible avec un clic droit sur l&#39;image, puis l&#39;option &quot;ouvrir l&#39;image dans un nouvel onglet&quot;. L&#39;url se trouve alors dans la barre d&#39;adresse de votre navigateur web.</p><p data-v-9603b154>Pour vous simplifier la vie, le tileset de ce tutoriel est d√©j√† publi√©, son url est : https://raw.githubusercontent.com/darkrecher/squarity-doc/master/user_manual/sokoban_tileset.png</p><h2 id="un-peu-dherbe" data-v-9603b154>Un peu d&#39;herbe <a class="header-anchor" href="#un-peu-dherbe" data-v-9603b154>üîó</a></h2><p data-v-9603b154>Nous allons cr√©er un premier programme qui fonctionne, mais qui ne constitue pas encore un vrai jeu. Allez sur le site http://squarity.fr .</p><p data-v-9603b154>Vous verrez un jeu de d√©monstration, que nous allons remplacer.</p><p data-v-9603b154>Dans le champ <em data-v-9603b154>&quot;Url de l&#39;image&quot;</em>, supprimez le texte existant, puis copier-collez le texte suivant :</p><p data-v-9603b154><code data-v-9603b154>https://raw.githubusercontent.com/darkrecher/squarity-doc/master/user_manual/sokoban_tileset.png</code></p><p data-v-9603b154>Dans le champ en-dessous <em data-v-9603b154>&quot;Config du jeu (en JSON)&quot;</em>, remplacez le texte existant par cette configuration :</p><pre data-v-9603b154><code data-v-9603b154>{
    &quot;version&quot;: &quot;1.0.0&quot;,
    &quot;tile_size&quot;: 32,
    &quot;img_coords&quot;: {
        &quot;herbe&quot;: [0, 0]
    }
}
</code></pre><p data-v-9603b154>Dans le dernier champ : <em data-v-9603b154>&quot;Le code du jeu (en python)&quot;</em>, remplacez le texte existant par ce code :</p><pre data-v-9603b154><code data-v-9603b154>class GameModel():

    def __init__(self):

        self.w = 20
        self.h = 14
        self.tiles = []

        for y in range(self.h):
            ligne = []
            for x in range(self.w):
                game_objects = []
                ligne.append(game_objects)
            self.tiles.append(ligne)

        self.tiles[3][5].append(&quot;herbe&quot;)

    def export_all_tiles(self):
        return self.tiles
</code></pre><p data-v-9603b154>Puis cliquez sur le bouton &quot;Ex√©cuter&quot; au milieu de la page.</p><p data-v-9603b154>Vous devriez voir un petit morceau d&#39;herbe dans le cadre de droite. Youpi !</p><p data-v-9603b154>Votre √©cran devrait ressembler √† ceci (certains boutons ont √©t√© supprim√©s pour simplifier l&#39;image) :</p><p data-v-9603b154><img src="`+u+`" alt="https://raw.githubusercontent.com/darkrecher/squarity-doc/master/user_manual/tuto_screenshot_01.png" data-v-9603b154></p><h2 id="bidouillons-un-peu" data-v-9603b154>Bidouillons un peu <a class="header-anchor" href="#bidouillons-un-peu" data-v-9603b154>üîó</a></h2><p data-v-9603b154>Nous allons modifier le code, pour essayer de comprendre ce que font certaines parties.</p><p data-v-9603b154>√Ä chaque modification, vous devez recliquer sur le bouton &quot;Ex√©cuter&quot;. Pour aller plus vite, vous pouvez utiliser le raccourci clavier Ctrl-Entr√©e.</p><p data-v-9603b154>Si votre code est incorrect, un message d&#39;erreur appara√Ætra en bas, que vous ne comprendrez pas forc√©ment. Le plus simple est alors de revenir √† une version du jeu qui fonctionne : faites des Ctrl-Z, ou au pire refaites les copi√©-coll√©s du chapitre pr√©c√©dent.</p><p data-v-9603b154>Dans la configuration du jeu, sur la ligne <code data-v-9603b154>&quot;herbe&quot;: [0, 0]</code>, remplacez l&#39;un des deux z√©ros par un nombre entre 1 et 64 et regardez le r√©sultat. Modifiez l&#39;autre nombre. Essayez de comprendre ce qu&#39;ils repr√©sentent. Pour vous aidez, vous pouvez r√©afficher dans un autre onglet l&#39;image du tileset que nous avons vu dans le premier chapitre.</p><p data-v-9603b154>Toujours dans la configuration du jeu, sur la ligne <code data-v-9603b154>&quot;tile_size&quot;: 32,</code>, remplacez le &quot;32&quot; par un autre nombre, entre 1 et 100. Essayez de comprendre ce que ce nombre repr√©sente.</p><p data-v-9603b154>Dans le code du jeu, sur la ligne <code data-v-9603b154>self.tiles[3][5].append(&quot;herbe&quot;)</code>, remplacez l&#39;un des deux nombres par un nombre entre 0 et 13. Modifiez l&#39;autre nombre. Essayez de comprendre ce que ces nombres repr√©sentent.</p><p data-v-9603b154>Lequel d√©finit l&#39;abscisse (X) du carr√© d&#39;herbe ? Lequel d√©finit son ordonn√©e (Y) ? Est-ce que l&#39;un des deux nombres pourrait √™tre plus grand que 13 ? Modifiez-le pour v√©rifier. Quelle est la valeur maximale pour X et la valeur maximale pour Y ?</p><p data-v-9603b154>Dupliquez la ligne :</p><pre data-v-9603b154><code data-v-9603b154>        self.tiles[3][5].append(&quot;herbe&quot;)
</code></pre><p data-v-9603b154>Attention √† l&#39;indentation, il faut garder les espaces au d√©but. Dans la ligne dupliqu√©e, modifiez le 3 et le 5. Que voyez-vous dans l&#39;aire de jeu ?</p><p data-v-9603b154>Vous pouvez re-dupliquer la ligne plusieurs fois si vous le souhaitez.</p><p data-v-9603b154>Ne vous emb√™tez pas √† la dupliquer des dizaines de fois pour remplir d&#39;herbe toute l&#39;aire de jeu. Il y a une m√©thode plus simple que nous verrons juste apr√®s.</p><p data-v-9603b154>Pour finir, appuyez sur les boutons du jeu : les fl√®ches ou les actions 1 et 2. Votre jeu va planter et affichera un message d&#39;erreur. C&#39;est normal, nous r√©glerons √ßa dans une √©tape ult√©rieure.</p><h2 id="quelques-explications-concernant-le-code" data-v-9603b154>Quelques explications concernant le code <a class="header-anchor" href="#quelques-explications-concernant-le-code" data-v-9603b154>üîó</a></h2><p data-v-9603b154>Le champ <em data-v-9603b154>&quot;config du jeu (en JSON)&quot;</em> ne contient pas votre programme, mais des informations structur√©es.</p><p data-v-9603b154>La ligne avec le mot <code data-v-9603b154>tile_size</code> d√©finit la taille des images (en pixels) dans le tileset. On gardera la valeur 32, sinon √ßa fait n&#39;importe quoi.</p><p data-v-9603b154>Les informations dans <code data-v-9603b154>img_coords</code> d√©finissent tous les types d&#39;objets que vous utilisez dans votre jeu. Pour l&#39;instant, il n&#39;y en a qu&#39;un seul, qui s&#39;appelle &quot;herbe&quot;.</p><p data-v-9603b154>Les deux valeurs entre crochets correspondent aux coordonn√©es, dans le tileset, de la portion d&#39;image de ce type d&#39;objet. Il s&#39;agit des coordonn√©es du coin sup√©rieur gauche. On rajoutera tr√®s vite les autres types d&#39;objets.</p><p data-v-9603b154>Le champ <em data-v-9603b154>&quot;code du jeu (en python)&quot;</em> contient votre programme. Ce programme doit d√©finir une classe intitul√©e <code data-v-9603b154>GameModel</code>.</p><p data-v-9603b154>Tout le code qui vient apr√®s d√©finit trois fonctions dans cette classe :</p><ul data-v-9603b154><li data-v-9603b154>la fonction <code data-v-9603b154>__init__</code>: la plus longue.</li><li data-v-9603b154>la fonction <code data-v-9603b154>export_all_tiles</code>, qui ne contient qu&#39;une ligne de code.</li></ul><p data-v-9603b154>Dans un environnement python plus classique, vous devez &quot;instancier&quot; votre classe pour l&#39;utiliser apr√®s. Vous n&#39;avez pas besoin de faire √ßa avec <code data-v-9603b154>GameModel</code>. Le syst√®me dans Squarity s&#39;occupe de l&#39;instancier et d&#39;appeler les bonnes fonctions aux bons moments.</p><p data-v-9603b154>Cependant, rien ne vous emp√™che de cr√©er vos propres classes et de les instancier quand vous en avez besoin.</p><p data-v-9603b154>Dans le code, les noms de variables commen√ßant par <code data-v-9603b154>self.</code> signifient qu&#39;elles appartiennent √† la classe. Elles sont accessible en lecture et en √©criture depuis toutes les fonctions de la classe. Leur valeur est conserv√©e entre deux &quot;tours&quot; de jeu.</p><p data-v-9603b154>Les variables ne commen√ßant pas par <code data-v-9603b154>self.</code>, par exemple <code data-v-9603b154>ligne</code> ou <code data-v-9603b154>game_objects</code> ne sont pas conserv√©es. Vous les d√©finissez et les utilisez dans une fonction, ensuite elles sont effac√©es.</p><p data-v-9603b154>Vous n&#39;avez pas besoin de savoir ce que signifie une &quot;classe&quot;, ni &quot;instancier une classe&quot; pour la suite de ce tutoriel. Si √ßa vous int√©resse, vous pouvez consulter des cours de python.</p><p data-v-9603b154>Les variables <code data-v-9603b154>self.w</code> et <code data-v-9603b154>self.h</code> d√©finissent la taille de l&#39;aire de jeu, en nombre de cases.</p><ul data-v-9603b154><li data-v-9603b154>w = width = largeur = 20 cases,</li><li data-v-9603b154>h = height = hauteur = 14 cases.</li></ul><p data-v-9603b154>La variable <code data-v-9603b154>self.tiles</code> est importante. Elle contient tous les objets √† afficher dans le jeu. C&#39;est un tableau en deux dimensions. Chaque case de ce tableau peut contenir plusieurs objets du jeu. Chacun est identifi√© par une cha√Æne de caract√®re, correspondant √† son nom.</p><p data-v-9603b154>Au d√©part, nous avons ajout√© un seul objet de jeu dans une seule case du tableau. Il a pour nom : &quot;herbe&quot;.</p><p data-v-9603b154>Selon ce que vous avez bidouill√© dans le chapitre pr√©c√©dent, vous en avez peut-√™tre ajout√© d&#39;autres.</p><p data-v-9603b154><img src="`+r+`" alt="https://raw.githubusercontent.com/darkrecher/squarity-doc/master/user_manual/annotations_code.png" data-v-9603b154></p><h2 id="plein-dherbe" data-v-9603b154>Plein d&#39;herbe <a class="header-anchor" href="#plein-dherbe" data-v-9603b154>üîó</a></h2><p data-v-9603b154>Dans le code du jeu, remplacez la ligne</p><pre data-v-9603b154><code data-v-9603b154>                game_objects = []
</code></pre><p data-v-9603b154>par</p><pre data-v-9603b154><code data-v-9603b154>                game_objects = [&quot;herbe&quot;]
</code></pre><p data-v-9603b154>Ex√©cutez votre jeu. Vous devriez voir de l&#39;herbe partout.</p><p data-v-9603b154>La ligne que vous venez de modifier se trouve dans une boucle (pour √™tre exact : dans une boucle de boucle). Elle est ex√©cut√©e pour chaque case de l&#39;aire de jeu, ce qui ajoute de l&#39;herbe partout.</p><p data-v-9603b154>La ligne <code data-v-9603b154>self.tiles[3][5].append(&quot;herbe&quot;)</code> n&#39;est plus utile, mais on va la garder pour l&#39;instant.</p><h2 id="attention-√†-lindentation" data-v-9603b154>Attention √† l&#39;indentation <a class="header-anchor" href="#attention-√†-lindentation" data-v-9603b154>üîó</a></h2><p data-v-9603b154>Vous avez peut-√™tre un peu de mal √† comprendre enti√®rement le code du jeu. Ne vous inqui√©tez pas, √ßa n&#39;emp√™che pas de terminer ce tutoriel.</p><p data-v-9603b154>Il y a cependant un point tr√®s important √† prendre en compte avec le langage de programmation python : l&#39;indentation est significative. Autrement dit : faites attention aux espaces qui se trouvent au d√©but de chaque ligne, ils servent √† indiquer la mani√®re dont les blocs de code sont imbriqu√©s.</p><p data-v-9603b154>Pour une explication plus d√©taill√©e, consultez <a href="https://python.developpez.com/cours/DiveIntoPython/php/frdiveintopython/getting_to_know_python/indenting_code.php" data-v-9603b154>cette page</a></p><h2 id="un-deuxi√®me-type-dobjet" data-v-9603b154>Un deuxi√®me type d&#39;objet <a class="header-anchor" href="#un-deuxi√®me-type-dobjet" data-v-9603b154>üîó</a></h2><p data-v-9603b154>L&#39;herbe c&#39;est bien, mais un peu monotone. Nous allons ajouter un nouveau type.</p><p data-v-9603b154>Remplacez la configuration du jeu par ceci :</p><pre data-v-9603b154><code data-v-9603b154>{
    &quot;version&quot;: &quot;1.0.0&quot;,
    &quot;tile_size&quot;: 32,
    &quot;img_coords&quot;: {
        &quot;herbe&quot;: [0, 0],
        &quot;mur&quot;: [32, 0]
    }
}
</code></pre><p data-v-9603b154>Vous avez maintenant deux types d&#39;objets, l&#39;herbe et le mur. N&#39;oubliez pas la virgule entre les deux.</p><p data-v-9603b154>Puis, dans le code du jeu, √† la ligne <code data-v-9603b154>self.tiles[3][5].append(&quot;herbe&quot;)</code>, remplacez le mot <code data-v-9603b154>&quot;herbe&quot;</code> par <code data-v-9603b154>&quot;mur&quot;</code>. Attention de bien garder les guillemets.</p><p data-v-9603b154>Ex√©cutez le jeu. Vous devriez voir de l&#39;herbe et un objet de type mur.</p><h2 id="vocabulaire-sp√©cifique-√†-squarity" data-v-9603b154>Vocabulaire sp√©cifique √† Squarity <a class="header-anchor" href="#vocabulaire-sp√©cifique-√†-squarity" data-v-9603b154>üîó</a></h2><p data-v-9603b154>Une image utilis√©e pour afficher un √©l√©ment dans l&#39;aire de jeu s&#39;appelle <strong data-v-9603b154>image de tile</strong>. Autres appellations : <strong data-v-9603b154>image de tuile</strong>, <strong data-v-9603b154>tile image</strong>, ou tout simplement <strong data-v-9603b154>image</strong>.</p><p data-v-9603b154>La grande image contenant toutes les images de tile s&#39;appelle le <strong data-v-9603b154>tileset</strong>. Autres appellations : <strong data-v-9603b154>tilesheet</strong>, <strong data-v-9603b154>image set</strong>, <strong data-v-9603b154>image atlas</strong>, <strong data-v-9603b154>atlas</strong>. On utilise le mot &quot;atlas&quot; pour repr√©senter le fait que c&#39;est un ensemble exhaustif, comme les atlas de cartes g√©ographiques.</p><p data-v-9603b154>Ce qui est affich√©e dans la partie droite de l&#39;√©cran s&#39;appelle <strong data-v-9603b154>l&#39;aire de jeu</strong>. C&#39;est l√† o√π tout se d√©roule : les personnages se d√©placent, ramassent des objets, discutent entre eux, etc.</p><p data-v-9603b154>Une case dans l&#39;aire de jeu s&#39;appelle une <strong data-v-9603b154>tile</strong>. Autres appellations : <strong data-v-9603b154>tuile</strong>, <strong data-v-9603b154>case</strong>. Ces tiles sont organis√©es sous forme d&#39;un tableau en deux dimensions. Dans notre programme, ce tableau est enregistr√© dans la variable <code data-v-9603b154>self.tiles</code>.</p><p data-v-9603b154>Pour rep√©rer une tile dans ce tableau, on utilise les coordonn√©es x et y.</p><p data-v-9603b154>X augmente lorsqu&#39;on va vers la droite. Les tiles tout √† gauche ont pour coordonn√©e x = 0. Les tiles tout √† droite ont pour coordonn√©e x = 19.</p><p data-v-9603b154>Y augmente lorsqu&#39;on va vers le bas. Les tiles tout en haut ont pour coordonn√©e y = 0. Les tiles tout en bas ont pour coordonn√©e y = 13.</p><p data-v-9603b154>Pour info : les graphiques des cours de maths ont la coordonn√©e Y dans l&#39;autre sens : Y augmente lorsqu&#39;on va vers le haut. En programmation, on pr√©f√®re que l&#39;axe des Y soit orient√© vers le bas. C&#39;est plus logique car √ßa correspond au sens de lecture et √† l&#39;ordre des pixels sur l&#39;√©cran.</p><p data-v-9603b154>Les coordonn√©es sont compt√©es √† partir de z√©ro, et non √† partir de un, parce que c&#39;est comme √ßa qu&#39;on fait en informatique. Il y a une justification, mais ce serait un peu long de l&#39;expliquer ici.</p><p data-v-9603b154>Un √©l√©ment plac√© dans une tile s&#39;appelle un <strong data-v-9603b154>objet de jeu</strong>. Autres appellations : <strong data-v-9603b154>game object</strong>, <strong data-v-9603b154>gamobj</strong>, <strong data-v-9603b154>gobject</strong>, <strong data-v-9603b154>gobj</strong>. Il peut y avoir plusieurs game objects sur une m√™me tile. Ils seront dessin√©s les uns par-dessus les autres.</p><p data-v-9603b154>Chaque game object est d√©fini par son <strong data-v-9603b154>type de game object</strong>. Autre appellation : <strong data-v-9603b154>game object type</strong>. Dans notre programme, les mots &quot;herbe&quot; et &quot;mur&quot; sont des types de game object.</p><p data-v-9603b154>Il faut essayer d&#39;utiliser ce vocabulaire pour les noms de variables dans vos programmes, afin qu&#39;il devienne commun aux personnes utilisant Squarity.</p><p data-v-9603b154>On √©vitera d&#39;utiliser les mots &quot;objet&quot; et &quot;type&quot; tout seul, car ce sont des termes trop g√©n√©riques, qui sont d√©j√† beaucoup utilis√©s en programmation.</p><p data-v-9603b154>On peut se permettre d&#39;utiliser les noms anglais (&quot;game object&quot;, &quot;tile&quot;, ...) dans un texte fran√ßais, puisque la langue fran√ßaise poss√®de d√©j√† des anglicismes. Vous pouvez aussi faire le contraire, car la langue anglaise poss√®de des francicismes. Ha ha ha.</p><p data-v-9603b154>Dans notre programme, nous avons commenc√© par placer dans chaque tile un seul game object, de type &quot;herbe&quot;. Puis, pour la tile qui est aux coordonn√©es (x=5, y=3), nous avons ajout√© un second game object, de type &quot;mur&quot;.</p><p data-v-9603b154><img src="`+i+`" alt="https://raw.githubusercontent.com/darkrecher/squarity-doc/master/user_manual/schema_self_tiles.png" data-v-9603b154></p><p data-v-9603b154>Dans la tile x=5, y=3, on ne voit pas le game object &quot;herbe&quot;, car le game object &quot;mur&quot; est dessin√© par dessus et la recouvre enti√®rement. Mais cette tile poss√®de bien deux game objects.</p><h2 id="quelques-r√®gles-du-fonctionnement-de-squarity" data-v-9603b154>Quelques r√®gles du fonctionnement de Squarity <a class="header-anchor" href="#quelques-r√®gles-du-fonctionnement-de-squarity" data-v-9603b154>üîó</a></h2><ul data-v-9603b154><li data-v-9603b154>On peut cr√©er et supprimer les game objects dans les tiles, et les d√©placer d&#39;une tile vers une autre.</li><li data-v-9603b154>Une tile peut contenir autant de game objects que l&#39;on veut.</li><li data-v-9603b154>Une tile peut poss√©der plusieurs game objects de m√™me type.</li><li data-v-9603b154>L&#39;ordre des game objects dans une tile est important, car il d√©finit l&#39;ordre dans lequel ils seront affich√©s.</li><li data-v-9603b154>On ne peut pas d√©placer, ajouter ou supprimer les tiles elles-m√™mes. Ce sont les cases du tableau, et le tableau ne change pas.</li><li data-v-9603b154>Il est possible de changer la taille de l&#39;aire de jeu, mais ce n&#39;est pas expliqu√© dans ce tutoriel.</li><li data-v-9603b154>On ne peut pas placer un game object sur plusieurs tiles en m√™me temps.</li><li data-v-9603b154><strong data-v-9603b154>On ne peut pas placer un game object √† cheval sur plusieurs tiles</strong>. Les coordonn√©es sont forc√©ment des nombres entiers. Vous ne pourrez donc jamais avoir un personnage qui se d√©place l√©g√®rement et se retrouve entre deux tiles, comme dans le premier Zelda ou dans les jeux Bombermans. C&#39;est un choix de conception dans Squarity, pour simplifier la cr√©ation des jeux.</li></ul><p data-v-9603b154>Les types de game object d&#39;un jeu sont tous r√©f√©renc√©s dans la donn√©e <code data-v-9603b154>img_coords</code> de la configuration.</p><h2 id="une-liste-de-liste-de-liste" data-v-9603b154>Une liste de liste de liste <a class="header-anchor" href="#une-liste-de-liste-de-liste" data-v-9603b154>üîó</a></h2><p data-v-9603b154>La notion de &quot;tableau&quot; n&#39;existe pas vraiment en python, on ne peut cr√©er que des listes.</p><p data-v-9603b154>Mais on peut cr√©er une liste contenant des listes.</p><ul data-v-9603b154><li data-v-9603b154>La variable <code data-v-9603b154>self.tiles</code> est une liste de 14 √©l√©ments, repr√©sentant les 14 lignes de l&#39;aire de jeu, <ul data-v-9603b154><li data-v-9603b154>chacun de ces √©l√©ments est une sous-liste de 20 √©l√©ments, repr√©sentant les 20 cases d&#39;une ligne de l&#39;aire de jeu, <ul data-v-9603b154><li data-v-9603b154>chacun de ces √©l√©ments est une sous-sous-liste ayant un nombre variable d&#39;√©l√©ments, repr√©sentant les game objects de la case, <ul data-v-9603b154><li data-v-9603b154>chacun de ces √©l√©ments est un nom, correspondant √† un type de game object.</li></ul></li></ul></li></ul></li></ul><p data-v-9603b154>Lorsqu&#39;on acc√®de √† des listes imbriqu√©es, on donne les index dans le m√™me ordre d&#39;imbrication.</p><p data-v-9603b154>Le code <code data-v-9603b154>self.tiles[3][5]</code> signifie : &quot;la ligne num√©ro 3, et dans cette ligne, la case num√©ro 5&quot;. On indique d&#39;abord l&#39;ordonn√©e (le y), et ensuite l&#39;abscisse (le x).</p><p data-v-9603b154>L&#39;acc√®s √† la tile de coordonn√©e (x, y) se fait avec ce code : <code data-v-9603b154>self.tiles[y][x]</code>. C&#39;est embarrassant, car l&#39;ordre est invers√© par rapport √† d&#39;habitude (d&#39;abord le x, puis le y).</p><p data-v-9603b154>Pour avoir un code plus clair, nous allons cr√©er une petite fonction qui renvoie une tile, avec les param√®tres dans l&#39;ordre.</p><p data-v-9603b154>Rajoutez ceci √† la fin du code du jeu :</p><pre data-v-9603b154><code data-v-9603b154>    def get_tile(self, x, y):
        return self.tiles[y][x]
</code></pre><p data-v-9603b154>Et ensuite, remplacez la ligne :</p><pre data-v-9603b154><code data-v-9603b154>        self.tiles[3][5].append(&quot;mur&quot;)
</code></pre><p data-v-9603b154>par la ligne :</p><pre data-v-9603b154><code data-v-9603b154>        self.get_tile(5, 3).append(&quot;mur&quot;)
</code></pre><p data-v-9603b154>Pensez √† bien garder le m√™me nombre d&#39;espace au d√©but de la ligne.</p><p data-v-9603b154>Ex√©cutez le jeu. Vous verrez la m√™me chose qu&#39;avant, mais maintenant nous avons une fonction qui remet les coordonn√©es dans l&#39;ordre habituel.</p><p data-v-9603b154>La fonction <code data-v-9603b154>append(&quot;game_object_type&quot;)</code> permet d&#39;ajouter un game object dans une tile. La fonction <code data-v-9603b154>remove(&quot;game_object_type&quot;)</code> permet d&#39;en supprimer un. Vous pouvez utiliser ces deux fonctions juste apr√®s un appel √† la fonction <code data-v-9603b154>self.get_tile(x, y)</code>.</p><p data-v-9603b154>Attention √† la fonction <code data-v-9603b154>remove</code>. Si vous indiquez un type de game object qui n&#39;est pas pr√©sent dans la tile, √ßa fera une erreur. Vous pouvez v√©rifier pr√©alablement la pr√©sence d&#39;un game object comme ceci :</p><pre data-v-9603b154><code data-v-9603b154>if &quot;mur&quot; in self.get_tile(5, 3):
    self.get_tile(5, 3).remove(&quot;mur&quot;)
</code></pre><h2 id="des-prints-des-prouts-et-du-python-pur" data-v-9603b154>Des prints, des prouts, et du python pur <a class="header-anchor" href="#des-prints-des-prouts-et-du-python-pur" data-v-9603b154>üîó</a></h2><p data-v-9603b154>Au tout d√©but du code du jeu, avant <code data-v-9603b154>class GameModel()</code>, ajoutez une ligne, et √©crivez :</p><p data-v-9603b154><code data-v-9603b154>print(&quot;prout&quot;)</code></p><p data-v-9603b154>Ex√©cutez le jeu. Vous devriez voir appara√Ætre, dans la fen√™tre en bas, le texte &quot;prout&quot;.</p><p data-v-9603b154>Juste apr√®s la ligne :</p><pre data-v-9603b154><code data-v-9603b154>        self.get_tile(5, 3).append(&quot;mur&quot;)
</code></pre><p data-v-9603b154>ajoutez ceci :</p><pre data-v-9603b154><code data-v-9603b154>        print(self.tiles)
</code></pre><p data-v-9603b154>Ex√©cutez le jeu. Vous devriez voir appara√Ætre un grand texte avec beaucoup de mots &quot;herbe&quot;. Il s&#39;agit du contenu complet de <code data-v-9603b154>self.tiles</code>.</p><p data-v-9603b154>Tout est √©crit sur une seule ligne, c&#39;est un peu difficile √† lire. Essayez de rep√©rer les double crochets ouvrants <code data-v-9603b154>[[</code> et fermants <code data-v-9603b154>]]</code>, ils marquent la coupure entre deux lignes de tiles. Vous devriez aussi trouver le mot &quot;mur&quot;.</p><p data-v-9603b154>La fonction <code data-v-9603b154>print</code> √©crit ce que vous lui indiquez en param√®tre. Du texte simple lorsqu&#39;il est mis entre guillemets, ou bien le contenu d&#39;une variable.</p><p data-v-9603b154>Cette fonction est tr√®s utile pour le d√©boguage, c&#39;est √† dire lorsque votre programme fait des messages d&#39;erreur ou qu&#39;il n&#39;ex√©cute pas ce que vous aviez pr√©vu. Vous placez des <code data-v-9603b154>print</code> √† diff√©rents endroits pour essayer de comprendre ce qu&#39;il se passe, le chemin d&#39;ex√©cution, le contenu des variables, etc.</p><p data-v-9603b154>Si vous n&#39;√™tes pas tr√®s √† l&#39;aise en python, vous pouvez vous entrainer en allant sur ce site : https://trinket.io/python3 . Il s&#39;agit d&#39;un interpr√©teur python dans votre navigateur. Vous √©crivez du code dans la partie gauche, vous cliquez sur le bouton &quot;Play&quot; et le r√©sultat de votre programme s&#39;affiche dans la partie droite.</p><h2 id="on-en-fait-des-caisses" data-v-9603b154>On en fait des caisses <a class="header-anchor" href="#on-en-fait-des-caisses" data-v-9603b154>üîó</a></h2><p data-v-9603b154>Pour cette √©tape, vous allez essayer de vous d√©brouiller un peu tout seul.</p><p data-v-9603b154>Vous devez faire les modifications n√©cessaires pour afficher une caisse √† c√¥t√© du mur :</p><p data-v-9603b154><img src="`+d+`" alt="https://raw.githubusercontent.com/darkrecher/squarity-doc/master/user_manual/tuto_screenshot_mur_et_caisse.png" data-v-9603b154></p><p data-v-9603b154>Dans la configuration du jeu, ajoutez un type de game object appel√© &quot;caisse&quot;. D√©finissez ses coordonnn√©es d&#39;image √† <code data-v-9603b154>[64, 0]</code>. N&#39;oubliez pas les virgules entre chaque d√©finition de type de game object.</p><p data-v-9603b154>Dans le code du jeu, copiez la ligne <code data-v-9603b154>self.get_tile(5, 3).append(&quot;mur&quot;)</code> et collez-la juste en dessous (attention aux espaces en d√©but de ligne !).</p><p data-v-9603b154>Dans cette nouvelle ligne de code, modifiez les coordonn√©es : la tile choisie doit √™tre un peu plus √† droite.</p><p data-v-9603b154>Ensuite, modifiez le type d&#39;objet : il faut que ce soit &quot;caisse&quot;.</p><p data-v-9603b154>Si vous n&#39;y arrivez pas, ce n&#39;est pas trop grave, vous pouvez quand m√™me passer au chapitre suivant.</p><h2 id="plein-dobjets-et-un-plan-du-niveau" data-v-9603b154>Plein d&#39;objets et un plan du niveau <a class="header-anchor" href="#plein-dobjets-et-un-plan-du-niveau" data-v-9603b154>üîó</a></h2><p data-v-9603b154>Dans le champ <em data-v-9603b154>&quot;Config du jeu&quot;</em>, supprimer l&#39;ancien texte et copier-collez la configuration suivante :</p><pre data-v-9603b154><code data-v-9603b154>{
    &quot;version&quot;: &quot;1.0.0&quot;,
    &quot;tile_size&quot;: 32,
    &quot;img_coords&quot;: {
        &quot;herbe&quot;: [0, 0],
        &quot;mur&quot;: [32, 0],
        &quot;caisse&quot;: [64, 0],
        &quot;personnage&quot;: [0, 32],
        &quot;cible&quot;: [32, 32]
    }
}
</code></pre><p data-v-9603b154>Dans le champ : <em data-v-9603b154>&quot;Le code du jeu&quot;</em>, supprimer l&#39;ancien texte et copier-collez le code suivant :</p><pre data-v-9603b154><code data-v-9603b154>PLAN_DU_NIVEAU = (
    &quot;                    &quot;,
    &quot;                $   &quot;,
    &quot;                    &quot;,
    &quot;    ######          &quot;,
    &quot;    #.              &quot;,
    &quot;    ####            &quot;,
    &quot;         $   @      &quot;,
    &quot;                    &quot;,
    &quot;           #    #   &quot;,
    &quot;           #    #   &quot;,
    &quot;           # .$ #   &quot;,
    &quot;           #  . #   &quot;,
    &quot;           ######   &quot;,
    &quot;                    &quot;,
)

corresp_game_objects_a_partir_char = {
    &quot; &quot;: [&quot;herbe&quot;],
    &quot;#&quot;: [&quot;mur&quot;],
    &quot;@&quot;: [&quot;personnage&quot;],
    &quot;$&quot;: [&quot;caisse&quot;],
    &quot;.&quot;: [&quot;cible&quot;]
}

class GameModel():

    def __init__(self):

        self.w = 20
        self.h = 14
        self.tiles = []

        for y in range(self.h):
            ligne_plan_du_niveau = PLAN_DU_NIVEAU[y]
            ligne = []
            for x in range(self.w):
                char_carte = ligne_plan_du_niveau[x]
                game_objects = corresp_game_objects_a_partir_char[char_carte]
                game_objects = list(game_objects)
                ligne.append(game_objects)
            self.tiles.append(ligne)

    def export_all_tiles(self):
        return self.tiles

    def get_tile(self, x, y):
        return self.tiles[y][x]

</code></pre><p data-v-9603b154>Ex√©cutez le jeu. Vous devriez voir ceci :</p><p data-v-9603b154><img src="`+l+`" alt="https://raw.githubusercontent.com/darkrecher/squarity-doc/master/user_manual/tuto_screenshot_level_map.png" data-v-9603b154></p><p data-v-9603b154>Que constate-t-on ? C&#39;est tr√®s moche !</p><h2 id="bidouillons-un-peu-et-rendons-√ßa-plus-beau" data-v-9603b154>Bidouillons un peu et rendons √ßa plus beau <a class="header-anchor" href="#bidouillons-un-peu-et-rendons-√ßa-plus-beau" data-v-9603b154>üîó</a></h2><p data-v-9603b154>Dans le programme que vous avez copi√©-coll√©, √† quel endroit est d√©finie la disposition des game objects dans l&#39;aire de jeu ? Essayez de changer cette disposition, par exemple en ajoutant ou en supprimant des caisses et des murs.</p><p data-v-9603b154>Essayez de comprendre pourquoi c&#39;est moche. Quel est le probl√®me avec les tiles contenant une cible, une caisse ou un personnage ? Qu&#39;est-ce qu&#39;il manque dans ces tiles ? Que faudrait-il faire pour qu&#39;elles s&#39;affichent en moins moche ?</p><p data-v-9603b154>Le plan du niveau est un ensemble de textes, contenant uniquement les caract√®res <code data-v-9603b154># @ $ .</code>. Pourtant, les noms de vos types d&#39;objets sont : &quot;herbe&quot;, &quot;mur&quot;, &quot;caisse&quot;, &quot;personnage&quot;, &quot;cible&quot;. √Ä quel caract√®re correspond quel type d&#39;objet ?</p><p data-v-9603b154>Dans le programme, o√π est d√©finie cette correspondance entre les caract√®res du plan du niveau et le nom des game objects ?</p><p data-v-9603b154>Pour que l&#39;affichage soit moins moche, vous avez uniquement besoin de modifier cette correspondance. Pas besoin de changer le reste du code.</p><p data-v-9603b154>Petit indice : si on prend le caract√®re &quot;$&quot;, celui-ci correspond √† <code data-v-9603b154>[&quot;caisse&quot;]</code>, c&#39;est √† dire : une liste avec un seul game object dedans, qui est de type &quot;caisse&quot;.</p><p data-v-9603b154>Dans un chapitre pr√©c√©dent, lorsqu&#39;on avait fait un print de la variable self.tiles, l&#39;une des cases avait pour valeur : <code data-v-9603b154>[&#39;herbe&#39;, &#39;mur&#39;]</code>.</p><p data-v-9603b154>Cette valeur peut √©galement s&#39;√©crire avec des guillemets double : <code data-v-9603b154>[&quot;herbe&quot;, &quot;mur&quot;]</code>. Elle signifie : une liste avec deux game objects dedans. Le premier est de type &quot;herbe&quot;, le second de type &quot;mur&quot;.</p><p data-v-9603b154>Et si vous mettiez des listes de plusieurs game objects dans la correspondance ente caract√®res et game objects ? Ce sera peut-√™tre mieux que d&#39;avoir des listes de un seul game object.</p><h2 id="la-r√©ponse-pour-que-ce-soit-plus-beau" data-v-9603b154>La r√©ponse pour que ce soit plus beau <a class="header-anchor" href="#la-r√©ponse-pour-que-ce-soit-plus-beau" data-v-9603b154>üîó</a></h2><p data-v-9603b154>Dans le code du jeu, remplacez cette partie :</p><pre data-v-9603b154><code data-v-9603b154>corresp_game_objects_a_partir_char = {
    &quot; &quot;: [&quot;herbe&quot;],
    &quot;#&quot;: [&quot;mur&quot;],
    &quot;@&quot;: [&quot;personnage&quot;],
    &quot;$&quot;: [&quot;caisse&quot;],
    &quot;.&quot;: [&quot;cible&quot;]
}
</code></pre><p data-v-9603b154>Par ceci :</p><pre data-v-9603b154><code data-v-9603b154>corresp_game_objects_a_partir_char = {
    &quot; &quot;: [&quot;herbe&quot;],
    &quot;#&quot;: [&quot;mur&quot;],
    &quot;@&quot;: [&quot;herbe&quot;, &quot;personnage&quot;],
    &quot;$&quot;: [&quot;herbe&quot;, &quot;caisse&quot;],
    &quot;.&quot;: [&quot;herbe&quot;, &quot;cible&quot;],
}
</code></pre><p data-v-9603b154>On a ajout√© le type de game object &quot;herbe&quot; dans toutes les listes, sauf les deux premi√®res.</p><p data-v-9603b154>Ex√©cutez le jeu, √ßa devrait √™tre plus beau, chaque objet devrait s&#39;afficher sur l&#39;herbe, au lieu d&#39;avoir un fond noir moche.</p><p data-v-9603b154>Un dernier petit d√©tail, pour les gens qui s&#39;y connaissent un peu en python. La ligne <code data-v-9603b154>game_objects = list(game_objects)</code> est importante. La fonction <code data-v-9603b154>list</code> permet de cr√©er une copie pour chaque tile. Si vous ne le faites pas, vous aurez plusieurs r√©f√©rences √† la m√™me liste. Lorsque vous changerez le contenu de l&#39;une des tiles (en ajoutant ou supprimant un game object), cela modifiera √©galement toutes les autres. On ne va pas rentrer plus loin dans les explications, tout ce que vous avez √† savoir pour ce tutoriel, c&#39;est qu&#39;il faut laisser cette ligne de code.</p><h2 id="petite-pause" data-v-9603b154>Petite pause <a class="header-anchor" href="#petite-pause" data-v-9603b154>üîó</a></h2><p data-v-9603b154>Si vous avez lu et effectu√© ce qui est demand√© jusqu&#39;ici, bravo ! Vous avez bien m√©rit√© une petite pause ! Mangez un morceau, jouez √† un jeu qui vous pla√Æt et nourrissez votre poisson rouge. Pour la suite, on s&#39;attaquera √† un gros morceau : l&#39;interactivit√© et le d√©placement du personnage.</p><p data-v-9603b154><img src="`+p+`" alt="https://www.clipartmax.com/middle/m2H7i8m2Z5N4K9K9_goldfish-fish-pixel-pixels-pixelart-aesthetic-localcupc-goldfish-pixel-art/" data-v-9603b154></p><h2 id="on-√©crit-pas-sur-les-murs" data-v-9603b154>On √©crit (pas sur les murs) <a class="header-anchor" href="#on-√©crit-pas-sur-les-murs" data-v-9603b154>üîó</a></h2><p data-v-9603b154>Dans le code du jeu, tout √† la fin, ajoutez la fonction suivante :</p><pre data-v-9603b154><code data-v-9603b154>    def on_game_event(self, event_name):
        print(event_name)
</code></pre><p data-v-9603b154>Ex√©cutez le jeu, puis cliquez sur les boutons. Le programme ne plante plus, et du texte s&#39;affiche en bas, selon le bouton appuy√© :</p><ul data-v-9603b154><li data-v-9603b154>&quot;U&quot; (up) : le bouton &quot;haut&quot;</li><li data-v-9603b154>&quot;D&quot; (down) : bouton &quot;bas&quot;</li><li data-v-9603b154>&quot;L&quot; (left) : bouton &quot;gauche&quot;</li><li data-v-9603b154>&quot;R&quot; (right) : bouton &quot;droit&quot;</li><li data-v-9603b154>&quot;action_1&quot; : bouton &quot;1&quot;</li><li data-v-9603b154>&quot;action_2&quot; : bouton &quot;2&quot;</li></ul><p data-v-9603b154>La fonction que vous avez ajout√©e se nomme <code data-v-9603b154>on_game_event</code>, elle se trouve √† l&#39;int√©rieur de la classe <code data-v-9603b154>GameModel</code>. Elle est sp√©ciale (on appelle √ßa une &quot;callback&quot;), car elle est ex√©cut√©e lorsqu&#39;on appuie sur un bouton du jeu. Le param√®tre <code data-v-9603b154>event_name</code> permet de savoir quel bouton a √©t√© appuy√©.</p><p data-v-9603b154>Vous pouvez ensuite √©crire du code dans la fonction, pour d√©clencher ce que vous voulez : ouvrir des portes, r√©pandre de la lave, t√©l√©porter des monstres, ...</p><h2 id="√ßa-bouge-" data-v-9603b154>√áa bouge ! <a class="header-anchor" href="#√ßa-bouge-" data-v-9603b154>üîó</a></h2><p data-v-9603b154>Pour commencer, il faut que le personnage se d√©place. C&#39;est l&#39;√©l√©ment principal du jeu, il m√©rite bien quelques variables que pour lui.</p><p data-v-9603b154>Dans la fonction d&#39;initialisation, juste apr√®s la ligne <code data-v-9603b154>def __init__(self):</code>, ajoutez ces deux lignes :</p><pre data-v-9603b154><code data-v-9603b154>        self.personnage_x = 13
        self.personnage_y = 6
</code></pre><p data-v-9603b154>Puis, dans la fonction <code data-v-9603b154>on_game_event</code> (c&#39;est √† dire √† la fin du code du jeu), ajoutez ce code :</p><pre data-v-9603b154><code data-v-9603b154>        tile_personnage = self.get_tile(self.personnage_x, self.personnage_y)
        if &quot;personnage&quot; in tile_personnage:
            tile_personnage.remove(&quot;personnage&quot;)

        self.personnage_x += 1

        tile_personnage = self.get_tile(self.personnage_x, self.personnage_y)
        tile_personnage.append(&quot;personnage&quot;)
</code></pre><p data-v-9603b154>Ex√©cutez le jeu.</p><p data-v-9603b154>Appuyez sur un bouton, n&#39;importe lequel. √Ä chaque fois, le personnage se d√©placera vers la droite. Arriv√© au bord du jeu, √ßa plante.</p><p data-v-9603b154>C&#39;est un d√©but.</p><h2 id="rebidouillons-un-peu" data-v-9603b154>Rebidouillons un peu <a class="header-anchor" href="#rebidouillons-un-peu" data-v-9603b154>üîó</a></h2><p data-v-9603b154>Dans la fonction <code data-v-9603b154>on_game_event</code>, nous avons ajout√© trois morceaux de code, s√©par√©s par une ligne vide. Le premier supprime le personnage de l&#39;aire de jeu, le deuxi√®me modifie ses coordonn√©es, le troisi√®me le replace √† sa nouvelle position.</p><p data-v-9603b154>Le deuxi√®me bloc de code ne contient qu&#39;une seule ligne : <code data-v-9603b154>self.personnage_x += 1</code>. L&#39;op√©rateur <code data-v-9603b154>+=</code> permet d&#39;ajouter une valeur √† une variable. L&#39;op√©rateur <code data-v-9603b154>-=</code> permet de soustraire.</p><p data-v-9603b154>Mettez une autre valeur que &quot;1&quot; dans cette ligne de code et essayez de comprendre ce que √ßa fait.</p><p data-v-9603b154>Remettez la valeur &quot;1&quot;. Essayez de faire en sorte que le personnage se d√©place vers la gauche lorsqu&#39;on appuie sur un bouton, puis vers le haut, puis vers le bas.</p><p data-v-9603b154>C&#39;est amusant, mais vous n&#39;avez toujours pas de personnage se d√©pla√ßant dans la bonne direction selon le bouton appuy√©.</p><h2 id="√ßa-bouge-mieux" data-v-9603b154>√áa bouge mieux <a class="header-anchor" href="#√ßa-bouge-mieux" data-v-9603b154>üîó</a></h2><p data-v-9603b154>Remplacez la ligne que vous avez bidouill√© :</p><pre data-v-9603b154><code data-v-9603b154>        self.personnage_x += 1
</code></pre><p data-v-9603b154>Par tout ce bloc :</p><pre data-v-9603b154><code data-v-9603b154>        if event_name == &quot;R&quot;:
            self.personnage_x += 1
        elif event_name == &quot;L&quot;:
            self.personnage_x -= 1
        if event_name == &quot;D&quot;:
            self.personnage_y += 1
        if event_name == &quot;U&quot;:
            self.personnage_y -= 1
</code></pre><p data-v-9603b154>Ex√©cutez le jeu.</p><p data-v-9603b154>Cette fois-ci, le personnage devrait pouvoir se d√©placer dans les 4 directions.</p><p data-v-9603b154>Essayez de sortir des bords de l&#39;aire de jeu. √Ä droite et en bas, √ßa fera une erreur et vous devrez re-ex√©cutez le jeu.</p><p data-v-9603b154>En haut et √† gauche, le personnage r√©appara√Ætra de l&#39;autre c√¥t√©.</p><p data-v-9603b154>Il y a une raison √† cela, provenant de la mani√®re dont les √©l√©ments d&#39;une liste sont index√©s. Vous trouverez des explications √† ce sujet dans des cours de python, si √ßa vous int√©resse. Juste comme √ßa rapidement : <code data-v-9603b154>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;][0] == &quot;a&quot;</code> et <code data-v-9603b154>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;][-1] == &quot;d&quot;</code>.</p><p data-v-9603b154><img src="`+c+`" alt="https://raw.githubusercontent.com/darkrecher/squarity-doc/master/user_manual/tuto_move_border.png" data-v-9603b154></p><h2 id="emp√™cher-le-personnage-de-d√©passer-les-bords" data-v-9603b154>Emp√™cher le personnage de d√©passer les bords <a class="header-anchor" href="#emp√™cher-le-personnage-de-d√©passer-les-bords" data-v-9603b154>üîó</a></h2><p data-v-9603b154>Dans le code du jeu, remplacez toute la fonction <code data-v-9603b154>on_game_event</code> par ce code :</p><pre data-v-9603b154><code data-v-9603b154>    def on_game_event(self, event_name):

        personnage_dest_x = self.personnage_x
        personnage_dest_y = self.personnage_y

        if event_name == &quot;R&quot;:
            personnage_dest_x += 1
        elif event_name == &quot;L&quot;:
            personnage_dest_x -= 1
        if event_name == &quot;D&quot;:
            personnage_dest_y += 1
        if event_name == &quot;U&quot;:
            personnage_dest_y -= 1

        if not (0 &lt;= personnage_dest_x &lt; self.w and 0 &lt;= personnage_dest_y &lt; self.h):
            return

        tile_personnage = self.get_tile(self.personnage_x, self.personnage_y)
        if &quot;personnage&quot; in tile_personnage:
            tile_personnage.remove(&quot;personnage&quot;)

        self.personnage_x = personnage_dest_x
        self.personnage_y = personnage_dest_y

        tile_personnage = self.get_tile(self.personnage_x, self.personnage_y)
        tile_personnage.append(&quot;personnage&quot;)
</code></pre><p data-v-9603b154>Le personnage ne peut plus sortir de l&#39;aire de jeu.</p><p data-v-9603b154>Voici ce que fait le code que nous venons d&#39;ajouter :</p><ul data-v-9603b154><li data-v-9603b154>Cr√©ation des variables temporaires <code data-v-9603b154>personnage_dest_x</code> et <code data-v-9603b154>personnage_dest_y</code>. Initialisation aux coordonn√©es actuelles du personnage.</li><li data-v-9603b154>Modification de l&#39;une de ces deux variables, selon le d√©placement √† faire, comme dans le chapitre pr√©c√©dent.</li><li data-v-9603b154>V√©rification que le personnage sort par un bord.</li><li data-v-9603b154>Si il sort, le mouvement n&#39;est pas appliqu√©. On quitte directement la fonction, en utilisant l&#39;instruction python <code data-v-9603b154>return</code>.</li><li data-v-9603b154>Si il ne sort pas, on applique le mouvement.</li><li data-v-9603b154>Comme pr√©c√©demment, on enl√®ve le game object, on modifie les coordonn√©es r√©elles du personnage, on rajoute le game object √† la nouvelle position.</li></ul><h2 id="placement-initial-du-personnage" data-v-9603b154>Placement initial du personnage <a class="header-anchor" href="#placement-initial-du-personnage" data-v-9603b154>üîó</a></h2><p data-v-9603b154>Petite bidouille : la variable <code data-v-9603b154>PLAN_DU_NIVEAU</code>, au d√©but du code, indique o√π se trouvent les diff√©rents objets. Le personnage est repr√©sent√© par le caract√®re <code data-v-9603b154>@</code>. Placez ce caract√®re √† un autre endroit du plan, ex√©cutez le jeu, d√©placez le personnage. Est-ce que √ßa fonctionne comme il faut ? Manifestement non.</p><p data-v-9603b154>Lors de l&#39;initialisation du jeu, la valeur des variables <code data-v-9603b154>self.personnage_x</code> et <code data-v-9603b154>self.personnage_y</code> devrait d√©pendre du plan du niveau, et plus pr√©cis√©ment de l&#39;endroit o√π se trouve le caract√®re &quot;@&quot;.</p><p data-v-9603b154>Il faut parcourir tout le plan du niveau, rep√©rer le caract√®re &quot;@&quot;, prendre ses coordonn√©es et les placer dans ces deux variables.</p><p data-v-9603b154>Nous effectuons d√©j√† un parcours du plan au d√©but du jeu, profitons-en !</p><p data-v-9603b154>Dans la fonction <code data-v-9603b154>def __init__(self)</code>, dans la boucle de boucle, juste apr√®s la ligne de code <code data-v-9603b154>ligne.append(game_objects)</code>, ajoutez le code suivant :</p><pre data-v-9603b154><code data-v-9603b154>                if char_carte == &quot;@&quot;:
                    self.personnage_x = x
                    self.personnage_y = y
</code></pre><p data-v-9603b154>Comme d&#39;habitude, attention aux espaces au d√©but de chaque ligne.</p><p data-v-9603b154>Ex√©cutez le jeu. Il devrait fonctionner comme avant.</p><p data-v-9603b154>Dans la variable <code data-v-9603b154>PLAN_DU_NIVEAU</code>, d√©placez le caract√®re &quot;@&quot;.</p><p data-v-9603b154>Ex√©cutez le jeu. D√©placez le personnage. √áa devrait √™tre beaucoup mieux qu&#39;avant. Le personnage ne fait plus de t√©l√©portation bizarre.</p><p data-v-9603b154>Vous n&#39;avez maintenant plus besoin de ces deux lignes qui sont rest√©es au d√©but de la fonction :</p><pre data-v-9603b154><code data-v-9603b154>        self.personnage_x = 13
        self.personnage_y = 6
</code></pre><p data-v-9603b154>Vous pouvez tester une mini-bidouille : remodifiez le <code data-v-9603b154>PLAN_DU_NIVEAU</code> en ajoutant plusieurs caract√®res &quot;@&quot;. Ex√©cutez le jeu. On voit plusieurs personnages, mais un seul d&#39;entre eux se d√©place.</p><p data-v-9603b154>Ajoutez ou d√©placez des caract√®res &quot;@&quot; comme vous le souhaitez, essayez de rep√©rer √† chaque fois quel est le personnage qui sera d√©pla√ßable. Il n&#39;est pas choisi au hasard.</p><p data-v-9603b154>Dans la suite de ce tutoriel, on gardera des niveaux avec un seul caract√®re &quot;@&quot;. On ne g√®re pas le cas avec plusieurs personnages. Mais rien ne vous emp√™che de cr√©er une autre version du jeu o√π ce serait g√©r√©.</p><h2 id="on-se-cogne-sur-les-murs" data-v-9603b154>On se cogne sur les murs <a class="header-anchor" href="#on-se-cogne-sur-les-murs" data-v-9603b154>üîó</a></h2><p data-v-9603b154>Un personnage qui passe √† travers tout, c&#39;est un super-pouvoir g√©nial. Mais √ßa ne fait pas un jeu tr√®s int√©ressant.</p><p data-v-9603b154>Avant d&#39;effectuer le mouvement, il faut v√©rifier le contenu de la case de destination. Si cette case contient un game object de type &quot;mur&quot;, il faut annuler le mouvement.</p><p data-v-9603b154>Il est possible que vous soyez un peu dans les choux apr√®s ces nombreuses modifs dans le code. C&#39;est comme √ßa que fonctionne la programmaton. On rajoute des petits morceaux au fur et √† mesure. Tout n&#39;est pas √©crit d&#39;une traite du d√©but √† la fin.</p><p data-v-9603b154>Je vais quand m√™me vous aider, voici un r√©capitutif complet du code, avec la gestion des murs.</p><p data-v-9603b154>Effacez tout le code de votre jeu, et copier-collez √† la place ce gigantesque texte :</p><pre data-v-9603b154><code data-v-9603b154>PLAN_DU_NIVEAU = (
    &quot;                    &quot;,
    &quot;                $   &quot;,
    &quot;                    &quot;,
    &quot;    ######          &quot;,
    &quot;    #.              &quot;,
    &quot;    ####            &quot;,
    &quot;         $   @      &quot;,
    &quot;                    &quot;,
    &quot;           #    #   &quot;,
    &quot;           #    #   &quot;,
    &quot;           # .$ #   &quot;,
    &quot;           #  . #   &quot;,
    &quot;           ######   &quot;,
    &quot;                    &quot;,
)

corresp_game_objects_a_partir_char = {
    &quot; &quot;: [&quot;herbe&quot;],
    &quot;#&quot;: [&quot;herbe&quot;, &quot;mur&quot;],
    &quot;@&quot;: [&quot;herbe&quot;, &quot;personnage&quot;],
    &quot;$&quot;: [&quot;herbe&quot;, &quot;caisse&quot;],
    &quot;.&quot;: [&quot;herbe&quot;, &quot;cible&quot;],
}

class GameModel():

    def __init__(self):

        self.w = 20
        self.h = 14
        self.tiles = []

        for y in range(self.h):
            ligne_plan_du_niveau = PLAN_DU_NIVEAU[y]
            ligne = []
            for x in range(self.w):
                char_carte = ligne_plan_du_niveau[x]
                game_objects = corresp_game_objects_a_partir_char[char_carte]
                game_objects = list(game_objects)
                if char_carte  == &quot;@&quot;:
                    self.personnage_x = x
                    self.personnage_y = y
                ligne.append(game_objects)
            self.tiles.append(ligne)

    def export_all_tiles(self):
        return self.tiles

    def get_tile(self, x, y):
        return self.tiles[y][x]

    def on_game_event(self, event_name):

        personnage_dest_x = self.personnage_x
        personnage_dest_y = self.personnage_y

        if event_name == &quot;R&quot;:
            personnage_dest_x += 1
        elif event_name == &quot;L&quot;:
            personnage_dest_x -= 1
        if event_name == &quot;D&quot;:
            personnage_dest_y += 1
        if event_name == &quot;U&quot;:
            personnage_dest_y -= 1

        if not (0 &lt;= personnage_dest_x &lt; self.w and 0 &lt;= personnage_dest_y &lt; self.h):
            return

        tile_dest = self.get_tile(personnage_dest_x, personnage_dest_y)
        if &quot;mur&quot; in tile_dest:
            return

        tile_personnage = self.get_tile(self.personnage_x, self.personnage_y)
        if &quot;personnage&quot; in tile_personnage:
            tile_personnage.remove(&quot;personnage&quot;)

        self.personnage_x = personnage_dest_x
        self.personnage_y = personnage_dest_y

        tile_personnage = self.get_tile(self.personnage_x, self.personnage_y)
        tile_personnage.append(&quot;personnage&quot;)
</code></pre><p data-v-9603b154>Ex√©cutez le jeu. √áa devrait fonctionner. Le personnage se d√©place, mais ne peut pas aller sur les murs.</p><h2 id="seconde-petite-pause" data-v-9603b154>Seconde petite pause <a class="header-anchor" href="#seconde-petite-pause" data-v-9603b154>üîó</a></h2><p data-v-9603b154>Re-nourrissez votre poisson rouge, il en a besoin.</p><p data-v-9603b154><img src="`+v+`" alt="http://pixelartmaker.com/art/c9d0a98ae70ec58" data-v-9603b154></p><h2 id="on-pousse-des-caisses-mais-on-nen-largue-pas" data-v-9603b154>On pousse des caisses (mais on n&#39;en largue pas) <a class="header-anchor" href="#on-pousse-des-caisses-mais-on-nen-largue-pas" data-v-9603b154>üîó</a></h2><p data-v-9603b154>Vous allez bient√¥t avoir un jeu jouable. Il faudrait maintenant que le personnage puisse pousser les caisses.</p><p data-v-9603b154>Dans le chapitre pr√©c√©dent, nous avons ajout√© une v√©rification sur le contenu de la tile de destination. S&#39;il y a un mur, la fonction se termine tout de suite.</p><p data-v-9603b154>Il faut une v√©rification suppl√©mentaire. Si la tile de destination contient une caisse, il faut appliquer le m√™me mouvement sur la caisse et sur le personnage. C&#39;est √† dire qu&#39;on enl√®ve la caisse de la tile o√π elle se trouve, et on la remet sur une tile √† c√¥t√©.</p><p data-v-9603b154>Nous d√©finirons trois variables :</p><ul data-v-9603b154><li data-v-9603b154><code data-v-9603b154>tile_depart_perso</code> : la tile o√π se trouve le personnage au d√©part.</li><li data-v-9603b154><code data-v-9603b154>tile_dest_perso</code> : la tile de destination du personnage.</li><li data-v-9603b154><code data-v-9603b154>tile_dest_caisse</code> : la tile de destination de la caisse, si on pousse une caisse.</li></ul><p data-v-9603b154>On n&#39;a pas besoin d&#39;une variable <code data-v-9603b154>tile_depart_caisse</code>, car c&#39;est la m√™me tile que <code data-v-9603b154>tile_dest_perso</code>.</p><p data-v-9603b154>√áa ajoute beaucoup de modifications, mais uniquement dans la fonction <code data-v-9603b154>on_game_event</code>. Ci-dessous, la fonction compl√®te mise √† jour. Supprimez celle qui est dans le code du jeu et copier-collez celle-ci √† la place.</p><pre data-v-9603b154><code data-v-9603b154>    def on_game_event(self, event_name):

        tile_depart_perso = self.get_tile(self.personnage_x, self.personnage_y)
        personnage_dest_x = self.personnage_x
        personnage_dest_y = self.personnage_y

        if event_name == &quot;R&quot;:
            personnage_dest_x += 1
        elif event_name == &quot;L&quot;:
            personnage_dest_x -= 1
        if event_name == &quot;D&quot;:
            personnage_dest_y += 1
        if event_name == &quot;U&quot;:
            personnage_dest_y -= 1

        if not (0 &lt;= personnage_dest_x &lt; self.w and 0 &lt;= personnage_dest_y &lt; self.h):
            return

        tile_dest_perso = self.get_tile(personnage_dest_x, personnage_dest_y)

        if &quot;mur&quot; in tile_dest_perso:
            return

        if &quot;caisse&quot; in tile_dest_perso:
            caisse_dest_x = personnage_dest_x
            caisse_dest_y = personnage_dest_y
            if event_name == &quot;R&quot;:
                caisse_dest_x += 1
            elif event_name == &quot;L&quot;:
                caisse_dest_x -= 1
            if event_name == &quot;D&quot;:
                caisse_dest_y += 1
            if event_name == &quot;U&quot;:
                caisse_dest_y -= 1

            tile_dest_caisse = self.get_tile(caisse_dest_x, caisse_dest_y)
            tile_dest_perso.remove(&quot;caisse&quot;)
            tile_dest_caisse.append(&quot;caisse&quot;)

        if &quot;personnage&quot; in tile_depart_perso:
            tile_depart_perso.remove(&quot;personnage&quot;)

        tile_dest_perso.append(&quot;personnage&quot;)
        self.personnage_x = personnage_dest_x
        self.personnage_y = personnage_dest_y
</code></pre><p data-v-9603b154>Ex√©cutez le jeu et essayez de pousser une caisse.</p><h2 id="emp√™cher-les-caisses-daller-nimporte-o√π" data-v-9603b154>Emp√™cher les caisses d&#39;aller n&#39;importe o√π <a class="header-anchor" href="#emp√™cher-les-caisses-daller-nimporte-o√π" data-v-9603b154>üîó</a></h2><p data-v-9603b154>Essayez de pousser des caisses un peu partout. Woups ! √ßa devient bizarre. La caisse sort de l&#39;√©cran, se t√©l√©porte √©ventuellement de l&#39;autre c√¥t√©, rentre dans un mur, etc.</p><p data-v-9603b154>Lors d&#39;un mouvement, que ce soit un personnage ou une caisse, il faut effectuer les m√™mes v√©rifications. Si une v√©rification √©choute, il faut annuler tout le mouvement (du personnage et de la caisse).</p><p data-v-9603b154>On pourrait copier-coller des morceaux de code dans la fonction <code data-v-9603b154>on_game_event</code>. Mais √ßa ferait un code moche et plus difficile √† comprendre.</p><p data-v-9603b154>Nous avons d√©j√† une portion de code qui se r√©p√®te : l&#39;application d&#39;un mouvement sur des coordonn√©es.</p><p data-v-9603b154>Dans ces cas l√†, il faut essayer de ranger le code, de placer les morceaux qui se r√©p√®tent dans des fonctions et d&#39;utiliser ces fonctions. On appelle √ßa une &quot;factorisation&quot;.</p><p data-v-9603b154>Allons-y ! Resupprimez toute la fonction <code data-v-9603b154>on_game_event</code> et remplacez-l√† par tout le bazar qui suit :</p><pre data-v-9603b154><code data-v-9603b154>    def coord_mouvement(self, x, y, direction):
        if direction == &quot;R&quot;:
            x += 1
        elif direction == &quot;L&quot;:
            x -= 1
        if direction == &quot;D&quot;:
            y += 1
        if direction == &quot;U&quot;:
            y -= 1
        return (x, y)

    def verifier_mouvement(self, dest_x, dest_y):
        if not (0 &lt;= dest_x &lt; self.w and 0 &lt;= dest_y &lt; self.h):
            return False
        if &quot;mur&quot; in self.get_tile(dest_x, dest_y):
            return False
        return True

    def on_game_event(self, event_name):

        personnage_dest_x, personnage_dest_y = self.coord_mouvement(
            self.personnage_x,
            self.personnage_y,
            event_name
        )
        if not self.verifier_mouvement(personnage_dest_x, personnage_dest_y):
            return

        tile_depart_perso = self.get_tile(self.personnage_x, self.personnage_y)
        tile_dest_perso = self.get_tile(personnage_dest_x, personnage_dest_y)

        if &quot;caisse&quot; in tile_dest_perso:
            caisse_dest_x, caisse_dest_y = self.coord_mouvement(
                personnage_dest_x,
                personnage_dest_y,
                event_name
            )
            if not self.verifier_mouvement(caisse_dest_x, caisse_dest_y):
                return
            tile_dest_caisse = self.get_tile(caisse_dest_x, caisse_dest_y)

            tile_dest_perso.remove(&quot;caisse&quot;)
            tile_dest_caisse.append(&quot;caisse&quot;)

        tile_depart_perso.remove(&quot;personnage&quot;)
        tile_dest_perso.append(&quot;personnage&quot;)
        self.personnage_x = personnage_dest_x
        self.personnage_y = personnage_dest_y
</code></pre><p data-v-9603b154>Ex√©cutez le jeu. Essayez de pousser les caisses. Elles ne peuvent plus sortir de l&#39;aire de jeu et ne peuvent plus aller dans les murs.</p><h2 id="une-caisse-qui-encaisse" data-v-9603b154>Une caisse qui encaisse <a class="header-anchor" href="#une-caisse-qui-encaisse" data-v-9603b154>üîó</a></h2><p data-v-9603b154>Essayez de pousser une caisse sur une autre caisse.</p><p data-v-9603b154>Oups, bug ! Les deux caisses se retrouvent sur la m√™me tile. Si vous poussez encore une fois, l&#39;une des deux caisses se d√©place et le personnage se retrouve sur l&#39;autre caisse. C&#39;est amusant mais ce n&#39;est pas du tout ce qu&#39;on veut.</p><p data-v-9603b154>Il faut rajouter une derni√®re v√©rification : une caisse ne peut pas √™tre pouss√©e sur une autre caisse.</p><p data-v-9603b154>Cette v√©rification ne peut pas √™tre ajout√©e dans la fonction g√©n√©rique <code data-v-9603b154>verifier_mouvement</code>, car on s&#39;en sert pour v√©rifier √† la fois les mouvements des caisses et du personnage. Or, il y a une diff√©rence entre les deux types d&#39;objets : un personnage peut pousser une caisse mais une caisse ne peut pas pousser une caisse. On ne peut pas factoriser toute la v√©rification.</p><p data-v-9603b154>Il faut donc ajouter la derni√®re v√©rification dans la fonction <code data-v-9603b154>on_game_event</code>.</p><p data-v-9603b154>Apr√®s cette ligne :</p><pre data-v-9603b154><code data-v-9603b154>            tile_dest_caisse = self.get_tile(caisse_dest_x, caisse_dest_y)
</code></pre><p data-v-9603b154>Ajoutez ce code :</p><pre data-v-9603b154><code data-v-9603b154>            if &quot;caisse&quot; in tile_dest_caisse:
                return
</code></pre><p data-v-9603b154>Ex√©cutez le jeu. Essayez de pousser une caisse sur une autre caisse. √áa ne devrait plus √™tre possible.</p><h2 id="condition-de-victoire" data-v-9603b154>Condition de victoire <a class="header-anchor" href="#condition-de-victoire" data-v-9603b154>üîó</a></h2><p data-v-9603b154>Le jeu est maintenant jouable, mais il n&#39;est pas tr√®s fun.</p><p data-v-9603b154>Le but est d&#39;amener chaque caisse sur une cible. Mais si vous y parvenez, il ne se passera rien de sp√©cial. Le minimum serait d&#39;afficher un message de r√©compense.</p><p data-v-9603b154>Il faut consulter toutes les tiles de l&#39;aire de jeu. Si l&#39;une d&#39;elles contient une caisse mais pas de cible, cela signifie que les caisses n&#39;ont pas toutes √©t√© rang√©es, et le jeu n&#39;est pas gagn√©. Pas la peine de continuer la consultation des tiles. Mais si chaque caisse est sur une cible, alors on peut afficher un message.</p><p data-v-9603b154>Ce traitement est ind√©pendant de tous les traitements existant dans le code. Nous le placerons donc dans une fonction, m√™me si elle ne sera utilis√©e qu&#39;une seule fois.</p><p data-v-9603b154>Ajoutez ceci √† la fin du code :</p><pre data-v-9603b154><code data-v-9603b154>    def verifier_caisses_sur_cible(self):
        for y in range(self.h):
            for x in range(self.w):
                current_tile = self.get_tile(x, y)
                if &quot;caisse&quot; in current_tile and &quot;cible&quot; not in current_tile:
                    return False
        return True
</code></pre><p data-v-9603b154>On n&#39;a besoin de faire cette v√©rification que lorsqu&#39;une caisse a √©t√© d√©plac√©e.</p><p data-v-9603b154>Dans la fonction <code data-v-9603b154>on_game_event</code>, apr√®s cette ligne :</p><pre data-v-9603b154><code data-v-9603b154>            tile_dest_caisse.append(&quot;caisse&quot;)
</code></pre><p data-v-9603b154>Ajoutez ce morceau de code :</p><pre data-v-9603b154><code data-v-9603b154>            if self.verifier_caisses_sur_cible():
                print(&quot;Bravo, vous avez gagn√© !&quot;)
</code></pre><p data-v-9603b154>Ex√©cutez le jeu. Placez chaque caisse sur une cible. Vous verrez votre superbe message de f√©licitations s&#39;afficher en bas.</p><h2 id="le-grand-final" data-v-9603b154>Le grand final <a class="header-anchor" href="#le-grand-final" data-v-9603b154>üîó</a></h2><p data-v-9603b154>Voil√†, votre jeu est jouable et il affiche un message en cas de victoire. C&#39;est fun, yeah !</p><p data-v-9603b154>Il reste √† ajouter quelques d√©tails :</p><ul data-v-9603b154><li data-v-9603b154>D&#39;autres caract√®res dans le plan du niveau, pour repr√©senter une tile contenant √† la fois une caisse et une cible, et une une tile contenant √† la fois une cible et le personnage.</li><li data-v-9603b154>La possibilit√© de d√©finir plusieurs niveaux. Le jeu passe automatiquement au niveau suivant apr√®s une victoire.</li><li data-v-9603b154>Lorsqu&#39;on appuie deux fois de suite sur le bouton d&#39;action num√©ro 1, le niveau en cours est r√©initialis√©.</li></ul><p data-v-9603b154>Ce tutoriel est d√©j√† assez long comme √ßa et ces d√©tails ajoutent des morceaux de code un peu partout, je vais donc directement vous donner tout le code final.</p><p data-v-9603b154>Les niveaux sont d√©finis au d√©but du code, sous forme d&#39;une liste de variables structur√©es de la m√™me mani√®re que l&#39;ancienne variable <code data-v-9603b154>PLAN_DU_NIVEAU</code>. Vous pouvez ajouter, modifier, ou supprimer des niveaux comme bon vous semble.</p><p data-v-9603b154>Voici tous les caract√®res utilis√©s :</p><ul data-v-9603b154><li data-v-9603b154><code data-v-9603b154>#</code> : mur</li><li data-v-9603b154><code data-v-9603b154>@</code> : personnage</li><li data-v-9603b154><code data-v-9603b154>+</code> : personnage sur une cible</li><li data-v-9603b154><code data-v-9603b154>$</code> : caisse</li><li data-v-9603b154><code data-v-9603b154>*</code> : caisse sur une cible</li><li data-v-9603b154><code data-v-9603b154>.</code> : cible</li><li data-v-9603b154>&quot; &quot; (un espace) : rien</li></ul><p data-v-9603b154>Au final, votre jeu ressemblera √† ceci :</p><p data-v-9603b154><img src="`+q+`" alt="https://raw.githubusercontent.com/darkrecher/squarity-doc/master/user_manual/tuto_screenshot_final.png" data-v-9603b154></p><p data-v-9603b154>Effacez tout le code du jeu actuel, copier-collez tout le texte ci-dessous. Comme √ßa, m√™me si vous √™tes dans les choux et que vous n&#39;avez pas enti√®rement compris les √©tapes pr√©c√©dentes, vous avez votre jeu complet :</p><pre data-v-9603b154><code data-v-9603b154>PLANS_DES_NIVEAUX_ET_DESCRIPTIONS = (
    (
        &quot;Origine de ce niveau : http://www.sokobano.de/wiki/index.php?title=Optimizer&quot;,
        (
            &quot;                    &quot;,
            &quot;          ####      &quot;,
            &quot;         ##. ##     &quot;,
            &quot;     ##### .  #     &quot;,
            &quot;     #   #  # #     &quot;,
            &quot;     # $ #  # #     &quot;,
            &quot;     # $      #     &quot;,
            &quot;     ######  ##     &quot;,
            &quot;          # ##      &quot;,
            &quot;          # #       &quot;,
            &quot;          # #       &quot;,
            &quot;         ## ##      &quot;,
            &quot;         # @ #      &quot;,
            &quot;         #   #      &quot;,
        )
    ),
    (
        &quot;Origine : https://www.mathsisfun.com/games/sokoban.html (un peu transform√©)&quot;,
        (
            &quot;    #####           &quot;,
            &quot;    #   #      ###  &quot;,
            &quot;    #$  #      #.#  &quot;,
            &quot;  ###  $###    # #  &quot;,
            &quot;  #  $  $ #   ## ###&quot;,
            &quot;### # ### #   #   .#&quot;,
            &quot;#   # ### #####  ###&quot;,
            &quot;# $  $           ..#&quot;,
            &quot;########### ###  ###&quot;,
            &quot;          # # #   .#&quot;,
            &quot;          # # ## ###&quot;,
            &quot;          # #  # #  &quot;,
            &quot;          # #  #.#  &quot;,
            &quot;          #@#  ###  &quot;,
        )
    ),
    (
        &quot;Origine : https://www.mathsisfun.com/games/sokoban.html&quot;,
        (
            &quot;                    &quot;,
            &quot;                    &quot;,
            &quot;                    &quot;,
            &quot;         #####      &quot;,
            &quot;##########   #      &quot;,
            &quot; @      . $  #      &quot;,
            &quot;########## $.#      &quot;,
            &quot;       #.##$ #      &quot;,
            &quot;       # # . ##     &quot;,
            &quot;       #$ *$$.#     &quot;,
            &quot;       #   .  #     &quot;,
            &quot;       ## #####     &quot;,
            &quot;        # #         &quot;,
            &quot;        # #         &quot;,
        )
    ),
    (
        &quot;Origine : https://alonso-delarte.medium.com/the-basics-of-sokoban-level-formats-&quot;
        &quot;for-designing-your-own-sokoban-levels-51882a7a36f0&quot;,
        (
            &quot;       #####        &quot;,
            &quot;   #####   #####    &quot;,
            &quot;   #           #    &quot;,
            &quot;   #  ### ###  #    &quot;,
            &quot; #### #     # ####  &quot;,
            &quot;##    #  *  #    #  &quot;,
            &quot;   $  # *+*      #  &quot;,
            &quot;##    #  *  #    #  &quot;,
            &quot; #### #     # ####  &quot;,
            &quot;   #  ### ###  #    &quot;,
            &quot;   #           #    &quot;,
            &quot;   #####   #####    &quot;,
            &quot;       #####        &quot;,
            &quot;                    &quot;,
        ),
    ),
    (
        &quot;Bravo, vous avez r√©ussi tous les niveaux. Pourquoi ne pas en profiter pour cr√©er les v√¥tres ?&quot;,
        (
            &quot;         @          &quot;,
            &quot;#  #  ### #   #  #  &quot;,
            &quot;#  #  #    # #   #  &quot;,
            &quot;####  ##    #    #  &quot;,
            &quot;#  #  #     #       &quot;,
            &quot;#  #  ###   #    #  &quot;,
            &quot;                    &quot;,
            &quot;        ####        &quot;,
            &quot;       #    #       &quot;,
            &quot;      # .  . #      &quot;,
            &quot;      #      #      &quot;,
            &quot;      #  ..  #      &quot;,
            &quot;       #    #       &quot;,
            &quot;        ####        &quot;,
        ),
    ),
)

corresp_game_objects_a_partir_char = {
    &quot; &quot;: [&quot;herbe&quot;],
    &quot;#&quot;: [&quot;herbe&quot;, &quot;mur&quot;],
    &quot;@&quot;: [&quot;herbe&quot;, &quot;personnage&quot;],
    &quot;$&quot;: [&quot;herbe&quot;, &quot;caisse&quot;],
    &quot;.&quot;: [&quot;herbe&quot;, &quot;cible&quot;],
    &quot;+&quot;: [&quot;herbe&quot;, &quot;cible&quot;, &quot;personnage&quot;],
    &quot;*&quot;: [&quot;herbe&quot;, &quot;cible&quot;, &quot;caisse&quot;],
}

class GameModel():

    def debuter_niveau(self):

        description, plan_du_niveau = PLANS_DES_NIVEAUX_ET_DESCRIPTIONS[self.numero_niveau]
        print(description)
        print()
        self.tiles = []

        for y in range(self.h):
            ligne_plan_du_niveau = plan_du_niveau[y]
            ligne = []
            for x in range(self.w):
                char_carte = ligne_plan_du_niveau[x]
                game_objects = corresp_game_objects_a_partir_char[char_carte]
                game_objects = list(game_objects)
                if &quot;personnage&quot; in game_objects:
                    self.personnage_x = x
                    self.personnage_y = y
                ligne.append(game_objects)
            self.tiles.append(ligne)

    def __init__(self):
        self.w = 20
        self.h = 14
        self.numero_niveau = 0
        self.debuter_niveau()
        self.niveau_reussi = False
        self.confirm_reset_level = False

    def export_all_tiles(self):
        return self.tiles

    def get_tile(self, x, y):
        return self.tiles[y][x]

    def coord_mouvement(self, x, y, direction):
        if direction == &quot;R&quot;:
            x += 1
        elif direction == &quot;L&quot;:
            x -= 1
        if direction == &quot;D&quot;:
            y += 1
        if direction == &quot;U&quot;:
            y -= 1
        return (x, y)

    def verifier_mouvement(self, dest_x, dest_y):
        if not (0 &lt;= dest_x &lt; self.w and 0 &lt;= dest_y &lt; self.h):
            return False
        if &quot;mur&quot; in self.get_tile(dest_x, dest_y):
            return False
        return True

    def verifier_caisses_sur_cible(self):
        for y in range(self.h):
            for x in range(self.w):
                current_tile = self.get_tile(x, y)
                if &quot;caisse&quot; in current_tile and &quot;cible&quot; not in current_tile:
                    return False
        return True

    def on_game_event(self, event_name):

        if self.niveau_reussi:
            self.numero_niveau += 1
            self.debuter_niveau()
            self.niveau_reussi = False
            return

        if event_name == &quot;action_1&quot;:
            if self.confirm_reset_level:
                self.debuter_niveau()
                self.confirm_reset_level = False
                print(&quot;r√©initialisation niveau&quot;)
            else:
                self.confirm_reset_level = True
                print(&quot;Appuyez √† nouveau sur le bouton &#39;1&#39;&quot;)
                print(&quot;pour confirmer la r√©initialisation du niveau.&quot;)
            return

        self.confirm_reset_level = False

        personnage_dest_x, personnage_dest_y = self.coord_mouvement(
            self.personnage_x,
            self.personnage_y,
            event_name
        )
        if not self.verifier_mouvement(personnage_dest_x, personnage_dest_y):
            return

        tile_depart_perso = self.get_tile(self.personnage_x, self.personnage_y)
        tile_dest_perso = self.get_tile(personnage_dest_x, personnage_dest_y)

        if &quot;caisse&quot; in tile_dest_perso:
            caisse_dest_x, caisse_dest_y = self.coord_mouvement(
                personnage_dest_x,
                personnage_dest_y,
                event_name
            )
            if not self.verifier_mouvement(caisse_dest_x, caisse_dest_y):
                return
            tile_dest_caisse = self.get_tile(caisse_dest_x, caisse_dest_y)
            if &quot;caisse&quot; in tile_dest_caisse:
                return

            tile_dest_perso.remove(&quot;caisse&quot;)
            tile_dest_caisse.append(&quot;caisse&quot;)
            if self.verifier_caisses_sur_cible():
                print(&quot;Bravo, vous avez gagn√© !&quot;)
                print(&quot;Appuyez sur un bouton pour passer au niveau suivant&quot;)
                print(&quot;&quot;)
                self.niveau_reussi = True

        tile_depart_perso.remove(&quot;personnage&quot;)
        tile_dest_perso.append(&quot;personnage&quot;)
        self.personnage_x = personnage_dest_x
        self.personnage_y = personnage_dest_y
</code></pre><p data-v-9603b154>Si vous en avez assez de faire des copi√©-coll√©s, vous pouvez directement jouer √† la version finale de ce sokoban <a href="https://squarity.pythonanywhere.com/game/#fetchez_tutorial_sokobanv1" data-v-9603b154>ici</a> .</p><p data-v-9603b154>J&#39;ai ajout√© plein de commentaires dans le code, pour le re-expliquer plus en d√©tail. √áa peut vous aider √† comprendre comment fonctionnne certaines parties.</p><p data-v-9603b154>Si vous √™tes arriv√©s jusqu&#39;ici, bravo ! N&#39;h√©sitez pas √† bidouiller le code autant que vous le pouvez, pour mieux comprendre comment il fonctionne. Consultez des tutoriels et des cours sp√©cifiques sur le python. Cr√©ez d&#39;autres jeux, ou modifiez celui-l√†. Bref : amusez-vous !</p>`,293)])])}const h=t(b,[["render",g],["__scopeId","data-v-9603b154"]]);export{h as default};
